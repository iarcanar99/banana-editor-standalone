#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üçå Banana Editor - Standalone Version
‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠ Image-to-Image editing ‡∏≠‡∏¥‡∏™‡∏£‡∏∞ ‡∏î‡πâ‡∏ß‡∏¢ Gemini 2.5 Flash API

‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå: ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡πÅ‡∏ö‡∏ö Image-to-Image editing ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏≠‡∏¥‡∏™‡∏£‡∏∞
‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏û‡∏∂‡πà‡∏á‡∏û‡∏≤ Promptist ‡∏´‡∏£‡∏∑‡∏≠ IPC communication
"""

import sys
import os
import traceback
from pathlib import Path
from typing import Optional, List
import json
from datetime import datetime
# IPC features removed for standalone version
# import socket
# import threading
import tempfile
import time
import re
from contextlib import contextmanager
import weakref

# Qt Imports
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QHBoxLayout, QVBoxLayout,
    QLabel, QPushButton, QFileDialog, QTextEdit, QScrollArea,
    QFrame, QSizePolicy, QMessageBox, QProgressBar, QComboBox, QDialog, QListWidget, QListWidgetItem, QGridLayout
)
from PySide6.QtCore import Qt, QThread, Signal as pyqtSignal, QTimer, QMimeData, QSettings, QRect, QPoint
from PySide6.QtGui import QPixmap, QFont, QPalette, QDragEnterEvent, QDropEvent, QPainter, QPainterPath, QCursor, QGuiApplication, QShortcut, QKeySequence, QColor, QPolygon, QWheelEvent

# Image Processing
from PIL import Image
from io import BytesIO

# Load environment variables
try:
    from dotenv import load_dotenv
    load_dotenv()  # Load .env file
except ImportError:
    # If python-dotenv is not installed, just continue
    pass


# ===== BANANA HISTORY SYSTEM =====

class BananaHistoryItem:
    """Simplified history item for Banana Editor - Manual add only"""
    def __init__(self, prompt_text: str, timestamp: datetime = None):
        self.text = prompt_text.strip()
        self.timestamp = timestamp or datetime.now()
        # ‡πÑ‡∏°‡πà‡∏°‡∏µ is_favorite ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ó‡∏∏‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô "favorite" (manual add ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
        
    def to_dict(self) -> dict:
        """Convert to dict for JSON storage"""
        return {
            'text': self.text,
            'timestamp': self.timestamp.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'BananaHistoryItem':
        """Create from dict"""
        return cls(
            prompt_text=data['text'],
            timestamp=datetime.fromisoformat(data['timestamp'])
        )

class BananaHistoryManager:
    """Simple history manager for Banana Editor only - Manual add only"""
    def __init__(self):
        self.history_file = Path("banana_history.json")  # ‡πÅ‡∏¢‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å Promptist
        self.max_items = 30  # ‡∏•‡∏î‡∏•‡∏á‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏õ‡πá‡∏ô manual add ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
        self.items = []
        self.load()  # ‡πÇ‡∏´‡∏•‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
        
    def add_prompt(self, text: str) -> bool:
        """Add new prompt to history (MANUAL ONLY - ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° ‚ûï)"""
        if not text.strip():
            return False
            
        # Check for duplicates ‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î)
        if self.items and self.items[-1].text.strip() == text.strip():
            return False  # ‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ã‡πâ‡∏≥
            
        item = BananaHistoryItem(text)
        self.items.append(item)  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î (‡πÉ‡∏´‡∏°‡πà‡∏™‡∏∏‡∏î)
        
        # Limit items - ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î
        if len(self.items) > self.max_items:
            self.items = self.items[1:]  # ‡∏•‡∏ö‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å‡∏≠‡∏≠‡∏Å (‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î)
            
        self.save()
        return True
    
    def remove_item(self, item: BananaHistoryItem) -> bool:
        """Remove specific item from history"""
        for i, hist_item in enumerate(self.items):
            if (hist_item.text == item.text and 
                hist_item.timestamp == item.timestamp):
                del self.items[i]
                self.save()
                return True
        return False
    
    def load(self):
        """‡πÇ‡∏´‡∏•‡∏î‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå"""
        if self.history_file.exists():
            try:
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.items = [
                        BananaHistoryItem.from_dict(item_data) 
                        for item_data in data.get('items', [])
                    ]
            except Exception as e:
                print(f"‚ö†Ô∏è Error loading banana history: {e}")
                self.items = []
    
    def save(self):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå"""
        try:
            data = {
                'items': [item.to_dict() for item in self.items],
                'created': datetime.now().isoformat()
            }
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"‚ö†Ô∏è Error saving banana history: {e}")

class HistoryLabel(QLabel):
    """‡πÅ‡∏ñ‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ñ‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç - ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å + focus highlight"""
    
    history_clicked = pyqtSignal(str, object)  # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡∏∞ label object ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å
    selection_changed = pyqtSignal(object)     # ‡∏™‡πà‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠ selection ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
    
    def __init__(self, item: BananaHistoryItem, sequence_number: int, parent=None):
        super().__init__(parent)
        self.item = item
        self.sequence_number = sequence_number  # ‡πÄ‡∏Å‡πá‡∏ö sequence ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
        self.is_focused = False  # ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ focus highlight
        self.is_selected = False  # ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ selection (‡πÉ‡∏´‡∏°‡πà)
        
        self.setup_ui()
        
    def setup_ui(self):
        """Setup label appearance ‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á + focus system"""
        # ‡πÉ‡∏ä‡πâ sequence number ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
        display_text = f"{self.sequence_number:02d}"  # ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏Ñ‡πà‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç 01, 02, 03...
        
        self.setText(display_text)
        self.setFixedSize(26, 40)  # ‡πÅ‡∏Ñ‡∏ö‡∏°‡∏≤‡∏Å ‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏û
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Tooltip ‡πÅ‡∏™‡∏î‡∏á preview (‡πÑ‡∏°‡πà‡∏°‡∏µ hover delete ‡πÅ‡∏•‡πâ‡∏ß)
        self.setToolTip(f"Click to select prompt #{self.sequence_number:02d}\n\n{self.item.text[:60]}...")
        
        # ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ mouse events
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.update_style()
    
    def update_style(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï styling ‡∏ï‡∏≤‡∏° selection state"""
        if self.is_selected:
            # Selected state - ‡∏™‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏î‡πà‡∏ô‡∏ä‡∏±‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            self.setStyleSheet("""
                QLabel {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                        stop:0 #4a7a4a, stop:0.5 #5a8a5a, stop:1 #4a7a4a);
                    color: #ffffff;
                    border: 2px solid #6a9a6a;
                    border-radius: 3px;
                    font-size: 8px;
                    font-weight: 600;
                    padding: 2px 1px;
                    margin: 1px 0px;
                }
            """)
        elif self.is_focused:
            # Focused state - highlight ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Promptist selected item
            self.setStyleSheet("""
                QLabel {
                    background-color: #3a5a3a;
                    color: #ffffff;
                    border: 1px solid #5a7b5a;
                    border-radius: 3px;
                    font-size: 8px;
                    font-weight: 600;
                    padding: 2px 1px;
                    margin: 1px 0px;
                }
            """)
        else:
            # Normal state
            self.setStyleSheet("""
                QLabel {
                    background-color: #2a4a2a;
                    color: #c8e6c9;
                    border: 1px solid #4a6b4a;
                    border-radius: 3px;
                    font-size: 8px;
                    font-weight: 500;
                    padding: 2px 1px;
                    margin: 1px 0px;
                }
                QLabel:hover {
                    background-color: #3a5a3a;
                    border-color: #5a7b5a;
                }
            """)
    
    def set_focused(self, focused: bool):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ focus state (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Promptist highlight system)"""
        self.is_focused = focused
        self.update_style()
    
    def set_selected(self, selected: bool):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ selection state (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà)"""
        self.is_selected = selected
        self.update_style()
        if selected:
            self.selection_changed.emit(self)
    
    
    def mousePressEvent(self, event):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å - toggle selection state ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á history_clicked ‡πÄ‡∏û‡∏∑‡πà‡∏≠ compatibility"""
        if event.button() == Qt.MouseButton.LeftButton:
            # Toggle selection ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á signal
            self.set_selected(not self.is_selected)
            # ‡∏™‡πà‡∏á history_clicked ‡πÄ‡∏û‡∏∑‡πà‡∏≠ compatibility ‡∏Å‡∏±‡∏ö old code
            self.history_clicked.emit(self.item.text, self)
        super().mousePressEvent(event)

# ===== END BANANA HISTORY SYSTEM =====

# IPCServer class removed for standalone version


class TextToImageWorker(QThread):
    """Worker thread for Text-to-Image generation (both Gemini and Imagen)"""
    
    images_generated = pyqtSignal(list)  # Generated image data list
    error_occurred = pyqtSignal(str)     # Error message
    status_update = pyqtSignal(str)      # Status updates
    
    def __init__(self, prompt: str, use_gemini: bool = True, aspect_ratio: str = "1:1"):
        super().__init__()
        self.prompt = prompt
        self.use_gemini = use_gemini
        self.aspect_ratio = aspect_ratio
        self.api_key = os.getenv("GEMINI_API_KEY")
        
    def run(self):
        """Run text-to-image generation"""
        try:
            self.status_update.emit("üîß ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û...")
            
            if not self.api_key:
                raise Exception("GEMINI_API_KEY not found in environment variables")
            
            if self.use_gemini:
                results = self._generate_with_gemini()
            else:
                results = self._generate_with_imagen4()
                
            if not results:
                raise Exception("No images received from API")
                
            self.images_generated.emit(results)
            
        except Exception as e:
            if "GEMINI_API_KEY not found" in str(e):
                self.error_occurred.emit("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö API Key - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ GEMINI_API_KEY")
            elif "No images received" in str(e):
                self.error_occurred.emit("‚ùå API ‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå - ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà")
            else:
                self.error_occurred.emit("‚ùå ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô")
    
    def _generate_with_gemini(self) -> List[bytes]:
        """Generate with Gemini 2.5 Flash"""
        try:
            self.status_update.emit("üöÄ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Gemini 2.5 Flash API...")
            
            # Import New SDK
            from google import genai
            from google.genai.types import GenerateContentConfig, Modality
            
            # Create client
            client = genai.Client(api_key=self.api_key)
            
            # Enhanced prompt for text-to-image
            enhanced_prompt = f"""
            Create a high-quality image based on this description: {self.prompt}
            
            Style: photorealistic, detailed, well-composed
            Output: single image with aspect ratio {self.aspect_ratio}
            """
            
            # Configure generation
            config = GenerateContentConfig(
                response_modalities=[Modality.IMAGE, Modality.TEXT],
                candidate_count=1
            )
            
            self.status_update.emit("‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û...")
            
            # Generate content
            response = client.models.generate_content(
                model="gemini-2.5-flash-image-preview",
                contents=enhanced_prompt,
                config=config
            )
            
            self.status_update.emit("üì• ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå...")
            
            # Extract images from response
            results = []
            if hasattr(response, 'candidates') and response.candidates:
                candidate = response.candidates[0]
                if hasattr(candidate, 'content') and candidate.content:
                    if hasattr(candidate.content, 'parts') and candidate.content.parts:
                        for part in candidate.content.parts:
                            if hasattr(part, 'inline_data') and part.inline_data and part.inline_data.data:
                                self.status_update.emit("‚úÖ ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö")
                                results.append(part.inline_data.data)
            
            if not results:
                raise Exception("No image data found in Gemini API response")
                
            return results
            
        except Exception as e:
            raise Exception(f"Gemini generation error: {str(e)}")
    
    def _generate_with_imagen4(self) -> List[bytes]:
        """Generate with Imagen 4.0"""
        try:
            self.status_update.emit("üöÄ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Imagen 4.0 API...")
            
            # Import New SDK
            from google import genai
            from google.genai import types
            
            # Create client
            client = genai.Client(api_key=self.api_key)
            
            self.status_update.emit("‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á...")
            
            # Generate with Imagen
            response = client.models.generate_images(
                model="imagen-4.0-generate-preview-06-06",
                prompt=self.prompt,
                config=types.GenerateImagesConfig(
                    number_of_images=1,
                    aspect_ratio=self.aspect_ratio,
                ),
            )
            
            self.status_update.emit("üì• ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå...")
            
            # Check if response and generated_images exist
            if not response or not hasattr(response, 'generated_images') or not response.generated_images:
                raise Exception("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏≤‡∏Å Imagen 4.0 API")
            
            # Convert PIL Images to bytes
            image_data_list = []
            for img in response.generated_images:
                if not img or not hasattr(img, 'image'):
                    continue
                    
                from io import BytesIO
                
                # Handle different image object types
                pil_image = img.image
                if not pil_image:
                    continue
                    
                if hasattr(pil_image, "_pil_image"):
                    pil_image = pil_image._pil_image
                elif not isinstance(pil_image, Image.Image):
                    if hasattr(pil_image, "tobytes"):
                        import numpy as np
                        if isinstance(pil_image, np.ndarray):
                            pil_image = Image.fromarray(pil_image)
                
                if pil_image:  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô save
                    buffer = BytesIO()
                    pil_image.save(buffer, "PNG")
                    image_data_list.append(buffer.getvalue())
            
            if not image_data_list:
                raise Exception("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏†‡∏≤‡∏û‡πÉ‡∏î ‡πÜ ‡∏à‡∏≤‡∏Å Imagen 4.0 ‡πÑ‡∏î‡πâ")
                
            return image_data_list
            
        except Exception as e:
            raise Exception(f"Imagen 4.0 generation error: {str(e)}")


class ImageEditWorker(QThread):
    """Worker thread ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Multiple Images Editing (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö contents parameter)"""
    
    # Signals
    finished = pyqtSignal(list)  # ‡∏™‡πà‡∏á list ‡∏Ç‡∏≠‡∏á image data
    error = pyqtSignal(str)      # ‡∏™‡πà‡∏á error message
    status_update = pyqtSignal(str)  # ‡∏™‡πà‡∏á status updates
    
    def __init__(self, contents: list, use_new_sdk: bool = True):
        super().__init__()
        self.contents = contents  # ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏°‡∏µ prompt ‡πÅ‡∏•‡∏∞ PIL.Image objects
        self.use_new_sdk = use_new_sdk
        self.api_key = os.getenv('GEMINI_API_KEY')
        
    def run(self):
        """Run the multiple images editing process"""
        try:
            self.status_update.emit("üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô...")
            
            if not self.api_key:
                self.error.emit("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö API Key - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ GEMINI_API_KEY")
                return
            
            self.status_update.emit("üîë ‡∏û‡∏ö API Key ‡πÅ‡∏•‡πâ‡∏ß")
            
            # Count images in contents (skip first item which is prompt)
            image_count = len(self.contents) - 1
            self.status_update.emit(f"üì∑ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• {image_count} ‡∏†‡∏≤‡∏û...")
            
            # Process with selected SDK
            if self.use_new_sdk:
                results = self._use_new_sdk()
            else:
                results = self._use_legacy_sdk()
                
            if not results:
                self.error.emit("‚ùå API ‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå - ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà")
                return
                
            self.status_update.emit("‚úÖ ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÅ‡∏•‡πâ‡∏ß")
            self.finished.emit(results)
            
        except Exception as e:
            try:
                # Safe error logging without encoding issues
                error_msg = str(e).encode('utf-8', errors='ignore').decode('utf-8')
                print(f"[ImageEditWorker] Error: {error_msg[:100]}")
            except:
                print("[ImageEditWorker] Error (encoding issue)")
            self.error.emit("‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡∏≠‡∏∑‡πà‡∏ô")
    
    def _use_new_sdk(self) -> List[bytes]:
        """‡πÉ‡∏ä‡πâ New SDK (google-genai) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Multiple Images editing"""
        try:
            # Import New SDK
            self.status_update.emit("üì¶ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î google-genai...")
            from google import genai
            from google.genai import types
            
            self.status_update.emit("üîß ‡∏™‡∏£‡πâ‡∏≤‡∏á Client...")
            client = genai.Client(api_key=self.api_key)
            
            # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° content ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö multimodal input (contents ‡∏ñ‡∏π‡∏Å‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß)
            # ‡πÄ‡∏û‡∏¥‡πà‡∏° aspect ratio ‡πÉ‡∏ô prompt
            enhanced_contents = self.contents.copy()
            if enhanced_contents and isinstance(enhanced_contents[0], str):
                enhanced_contents[0] = f"{enhanced_contents[0]}. Output the image in 1:1 aspect ratio."
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ config ‡∏û‡∏£‡πâ‡∏≠‡∏° safety settings ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢
            config = types.GenerateContentConfig(
                response_modalities=["IMAGE", "TEXT"],
                candidate_count=1,
                temperature=0.7,
                safety_settings=[
                    types.SafetySetting(
                        category="HARM_CATEGORY_HATE_SPEECH",
                        threshold="BLOCK_NONE"
                    ),
                    types.SafetySetting(
                        category="HARM_CATEGORY_HARASSMENT",
                        threshold="BLOCK_NONE"
                    ),
                    types.SafetySetting(
                        category="HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        threshold="BLOCK_NONE"
                    ),
                    types.SafetySetting(
                        category="HARM_CATEGORY_DANGEROUS_CONTENT",
                        threshold="BLOCK_NONE"
                    ),
                ]
            )
            
            self.status_update.emit("üöÄ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Multiple Images editing...")
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API ‡∏î‡πâ‡∏ß‡∏¢ contents ‡∏ó‡∏µ‡πà‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡πÑ‡∏ß‡πâ
            response = client.models.generate_content(
                model="gemini-2.5-flash-image-preview",
                contents=enhanced_contents,
                config=config
            )
            
            self.status_update.emit("üì• ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å API...")
            
            # Process response (‡πÉ‡∏ä‡πâ‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö BananaWorker)
            print(f"[DEBUG] Response received: {response}")
            print(f"[DEBUG] Candidates count: {len(response.candidates) if response.candidates else 0}")
            
            if not response.candidates:
                print("[DEBUG] No candidates in response - this indicates API rejection or billing issue")
                raise Exception("No candidates received from API - check API key billing status")
            
            candidate = response.candidates[0]
            
            if not candidate.content:
                raise Exception("No content received from API")
            
            if not candidate.content.parts:
                raise Exception("No parts received from content")
            
            results = []
            for part in candidate.content.parts:
                if hasattr(part, 'inline_data') and part.inline_data:
                    if hasattr(part.inline_data, 'data'):
                        image_data = part.inline_data.data
                        results.append(image_data)
                        self.status_update.emit(f"‚úÖ ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÅ‡∏•‡πâ‡∏ß ({len(results)} ‡∏†‡∏≤‡∏û)")
            
            if not results:
                raise Exception("No image data found in response")
            
            return results
            
        except Exception as e:
            try:
                # Safe error logging without encoding issues
                error_msg = str(e).encode('utf-8', errors='ignore').decode('utf-8')
                print(f"[ImageEditWorker] New SDK Error: {error_msg[:200]}")
            except:
                print("[ImageEditWorker] New SDK Error (cannot display details)")
            raise Exception("New SDK Error occurred")
    
    def _use_legacy_sdk(self) -> List[bytes]:
        """‡πÉ‡∏ä‡πâ Legacy SDK - placeholder (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö multiple images)"""
        raise Exception("Legacy SDK does not support Multiple Images - please use New SDK")




class BananaEditor(QMainWindow):
    """Main UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Banana Editor"""
    
    def __init__(self):
        super().__init__()
        self.selected_image_path = None
        self.worker = None
        self.current_results = []
        
        # üñºÔ∏è Multiple Start Images System
        self.image_slots = []  # List of 4 image slots
        self.image_paths = [None] * 4  # Store paths for slots 1-4
        
        # Session Management ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Multiple Images
        self.image_session = {
            'paths': [],                    # ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ path ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û (max 3)
            'thumbnails': [],              # QLabel objects ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á preview  
            'count': 0,                    # ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            'mode': 'single'               # 'single', 'dual', 'triple'
        }
        self.max_images_limit = 3          # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 3 ‡∏†‡∏≤‡∏û
        self.image_preview_layout = None   # Layout ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û responsive
        self.multi_image_container = None  # Container ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö dual/triple layout
        
        # Save location setting (default: True = original folder)
        self.save_on_original = True
        
        # Font size settings
        self.current_font_size = 11  # Default font size
        self.min_font_size = 8
        self.max_font_size = 30
        
        # Settings for caching
        self.settings = QSettings("BananaEditor", "Settings")
        # Load saved font size
        self.current_font_size = self.settings.value("font_size", 11, type=int)
        
        # IPC Server removed for standalone version
        # self.ipc_server = None
        
        # Floating Image Viewer
        self.floating_viewer = None
        self.temp_result_files = []  # Track temporary files for cleanup
        
        self.init_ui()
        self.check_environment()
        self.setup_shortcuts()
        # self.setup_ipc_server()  # IPC removed for standalone version
        
        # üßπ Ensure clean start - clear any residual slot data (before UI state update)
        self.clear_all_slots_on_startup()
        
        # Initialize UI state
        self.update_ui_state()
        
    def clear_all_slots_on_startup(self):
        """üßπ ‡∏•‡πâ‡∏≤‡∏á slots ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà preload)"""
        try:
            # Reset all image paths
            for i in range(4):
                self.image_paths[i] = None
            
            # Clear UI slots (if they exist)
            if hasattr(self, 'image_slots') and self.image_slots:
                for i, slot_widget in enumerate(self.image_slots):
                    if slot_widget:
                        image_label = slot_widget.findChild(QLabel)
                        if image_label:
                            image_label.clear()
                            image_label.setText(f"Slot {i + 1}")
                        
                        delete_btn = slot_widget.findChild(QPushButton)
                        if delete_btn:
                            delete_btn.setVisible(False)
            
            # Clear session data
            if hasattr(self, 'image_session'):
                self.image_session = {
                    'paths': [],
                    'thumbnails': [],
                    'count': 0,
                    'mode': 'single'
                }
            
            # Clear any temporary files
            if hasattr(self, 'temp_result_files'):
                self.temp_result_files.clear()
                
            print("[STARTUP-CLEANUP] All slots cleared for fresh start")
            
        except Exception as e:
            print(f"[STARTUP-CLEANUP] Error during cleanup: {e}")
        
    def init_ui(self):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á UI ‡∏´‡∏•‡∏±‡∏Å"""
        self.setWindowTitle("üçå Banana Editor: Beta v-1")
        self.setGeometry(100, 100, 1000, 650)  # ‡πÄ‡∏•‡πá‡∏Å‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
        
        # Remove window frame and make it movable
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, False)
        
        # Variables for window dragging and resizing
        self.drag_position = None
        self.resize_drag = False
        self.resize_start_pos = None
        self.resize_start_geometry = None
        
        # Enable drag and drop
        self.setAcceptDrops(True)
        
        # Focus state
        self.is_focused = True
        
        # History selection state
        self.selected_history_label = None  # ‡πÄ‡∏Å‡πá‡∏ö history label ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ß‡πâ
        
        # Set dark theme
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1f2e1f;
                color: #c8e6c9;
                border: 2px solid #608060;
            }
            QMainWindow:!active {
                border: 1px solid #304530;
            }
            QWidget {
                background-color: #1f2e1f;
                color: #c8e6c9;
            }
        """)
        
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QVBoxLayout(central_widget)
        main_layout.setSpacing(0)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        # Custom title bar with status
        title_bar = QWidget()
        title_bar.setFixedHeight(50)
        title_bar.setStyleSheet("""
            QWidget {
                background-color: #263a26;
                border-bottom: 1px solid #304530;
            }
        """)
        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(15, 0, 15, 0)
        
        # App title (left side)
        app_title = QLabel("Banana Editor v1.2")
        app_title.setStyleSheet("""
            QLabel {
                background-color: transparent;
                font-size: 14px;
                color: #c8e6c9;
                font-weight: 600;
                padding: 15px 0;
            }
        """)
        title_layout.addWidget(app_title)
        
        # Spacer to push status to the right
        title_layout.addStretch()
        
        # Status label (right side, draggable area)
        self.status_label = QLabel("üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö...")
        self.status_label.setStyleSheet("""
            QLabel {
                background-color: transparent;
                font-size: 12px;
                color: #c8e6c9;
                font-weight: 400;
                padding: 15px 0;
            }
        """)
        title_layout.addWidget(self.status_label)
        
        # Close button
        close_btn = QPushButton("‚úï")
        close_btn.setFixedSize(30, 30)
        close_btn.clicked.connect(self.close)
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #c8e6c9;
                border: none;
                font-size: 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #ff4444;
                color: white;
            }
        """)
        title_layout.addWidget(close_btn)
        
        main_layout.addWidget(title_bar)
        
        # Content layout
        content_layout = QHBoxLayout()
        content_layout.setSpacing(1)
        content_layout.setContentsMargins(0, 0, 0, 0)
        
        # Left Panel - File Selection & Thumbnail
        left_panel = self.create_left_panel()
        content_layout.addWidget(left_panel, 1)
        
        # Center Panel - Prompt Input
        center_panel = self.create_center_panel()
        content_layout.addWidget(center_panel, 1)
        
        # Right Panel - Results Display
        right_panel = self.create_right_panel()
        content_layout.addWidget(right_panel, 1)
        
        main_layout.addLayout(content_layout)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.progress_bar.setFixedHeight(16)  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡πâ‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô
        self.progress_bar.setMinimumWidth(200)  # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                background-color: #304530;
                border: 2px solid #608060;
                border-radius: 4px;
                text-align: center;
                color: #ffffff;
                font-size: 11px;
                font-weight: bold;
                padding: 1px;
            }
            QProgressBar::chunk {
                background: qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0,
                    stop: 0 #4CAF50, stop: 0.5 #66BB6A, stop: 1 #4CAF50);
                border-radius: 2px;
                margin: 0.5px;
            }
        """)
        main_layout.addWidget(self.progress_bar)
        
        # Error button (hidden by default)
        self.error_button = QPushButton("‚ùå Error Detail - ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î")
        self.error_button.setVisible(False)
        self.error_button.clicked.connect(self.show_error_detail)
        self.error_button.setStyleSheet("""
            QPushButton {
                background-color: #4a1f1f;
                color: #ff6b6b;
                border: 1px solid #5a3030;
                padding: 8px 15px;
                font-size: 12px;
                font-weight: 600;
                text-align: left;
            }
            QPushButton:hover {
                background-color: #5a2020;
                border: 1px solid #6a3535;
            }
            QPushButton:pressed {
                background-color: #3a1010;
            }
        """)
        main_layout.addWidget(self.error_button)
        
        # Variable to store error message for detail view
        self.last_error_message = ""
        
        # Initialize error translator
        self.setup_error_translator()
        
        # Add resize handle
        self.add_resize_handle()
        
        # ===== HISTORY INTEGRATION =====
        self.setup_history_integration()
        
        # Set initial status
        self.update_status("‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (Drag & Drop ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö)")
    
    # IPC functions removed for standalone version
    # def setup_ipc_server(self): ...
    # def on_ipc_image_received(self, image_path): ...
    # def on_ipc_prompt_received(self, prompt_text): ...
    
    # ===== HISTORY SYSTEM INTEGRATION =====
    
    def setup_history_integration(self):
        """‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ history system - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ 3 ‡∏õ‡∏∏‡πà‡∏°‡∏´‡∏•‡∏±‡∏Å"""
        # Button connections (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
        self.add_to_history_btn.clicked.connect(self.add_current_prompt_to_history)
        self.copy_prompt_btn.clicked.connect(self.copy_current_prompt)
        self.delete_history_btn.clicked.connect(self.delete_selected_history)
        self.clear_prompt_btn.clicked.connect(self.clear_prompt_text)
        
        # ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏° X ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡πÅ‡∏î‡∏á
        self.delete_history_btn.setStyleSheet("""
            QPushButton {
                background-color: #4a2a2a;
                color: #ff6666;
                border: 1px solid #6a4a4a;
                border-radius: 4px;
                font-size: 12px;
                font-weight: 600;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #6a3a3a;
                color: #ff8888;
                border-color: #8a5a5a;
            }
            QPushButton:pressed {
                background-color: #5a2a2a;
                color: #ffaaaa;
            }
        """)
        
        # Load existing history (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
        self.refresh_history_display()
        
        # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏° delete
        self.update_delete_button_state()
    
    def add_current_prompt_to_history(self):
        """‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏£‡∏≠‡∏°‡∏ï‡πå‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏•‡∏á history (MANUAL ONLY - ‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° ‚ûï)"""
        try:
            text = self.prompt_input.toPlainText().strip()
            
            if len(text) > 10:  # ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 10 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û
                success = self.history_manager.add_prompt(text)
                if success:
                    self.refresh_history_display()
                    self.update_status("‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß")
                else:
                    self.update_status("‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î")
            else:
                self.update_status("‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏±‡πâ‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡∏ï‡πâ‡∏≠‡∏á 10+ ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£)")
        except Exception as e:
            self.update_status(f"‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}")
            print(f"Error in add_current_prompt_to_history: {e}")
    
    def copy_current_prompt(self):
        """Copy prompt ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Promptist)"""
        text = self.prompt_input.toPlainText().strip()
        if text:
            # QGuiApplication already imported
            QGuiApplication.clipboard().setText(text)
            self.update_status("‚úÖ ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß")
        else:
            self.update_status("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å")
    
    def clear_prompt_text(self):
        """Clear ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Promptist)"""
        self.prompt_input.clear()
        self.prompt_input.setFocus()
        self.update_status("üìÑ ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡πâ‡∏ß")
    
    def refresh_history_display(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• history labels - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ manual history"""
        # Clear existing labels
        for i in reversed(range(self.history_layout.count())):
            child = self.history_layout.itemAt(i).widget()
            if child:
                child.deleteLater()
        
        # Store current focused label reference
        self.focused_history_label = None
        
        # ‡πÅ‡∏™‡∏î‡∏á/‡∏ã‡πà‡∏≠‡∏ô history panel ‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥ (Manual add only)
        if len(self.history_manager.items) > 0:
            self.history_panel.setVisible(True)
            
            # Add new labels (‡πÅ‡∏™‡∏î‡∏á 12 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏£‡∏Å) - ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î = 01
            display_items = self.history_manager.items[:12]  # ‡πÄ‡∏≠‡∏≤‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
            for i, item in enumerate(display_items):
                sequence_num = i + 1  # ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î = 01, ‡πÉ‡∏´‡∏°‡πà‡∏™‡∏∏‡∏î = 02...
                label = HistoryLabel(item, sequence_num)
                label.history_clicked.connect(self.load_prompt_from_history)
                label.selection_changed.connect(self.on_history_selection_changed)
                self.history_layout.addWidget(label)
            
            # Add stretch to push labels to top
            self.history_layout.addStretch()
        else:
            self.history_panel.setVisible(False)  # ‡∏ã‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ manual history
    
    def load_prompt_from_history(self, text: str, label_obj):
        """‡πÇ‡∏´‡∏•‡∏î‡∏û‡∏£‡∏≠‡∏°‡∏ï‡πå‡∏à‡∏≤‡∏Å history + ‡∏ï‡∏±‡πâ‡∏á focus highlight"""
        # Clear previous focus
        if hasattr(self, 'focused_history_label') and self.focused_history_label:
            self.focused_history_label.set_focused(False)
        
        # Set new focus (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Promptist highlight system)
        label_obj.set_focused(True)
        self.focused_history_label = label_obj
        
        # Load prompt
        self.prompt_input.setPlainText(text)
        self.prompt_input.setFocus()
        self.update_status(f"üìú ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥: {text[:30]}...")
    
    def on_history_selection_changed(self, label_obj):
        """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠ history ‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å - ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå selection ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡πÅ‡∏•‡∏∞‡πÄ‡∏Å‡πá‡∏ö selection ‡πÉ‡∏´‡∏°‡πà"""
        # ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå selection ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        for i in range(self.history_layout.count() - 1):  # -1 ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ stretch
            item = self.history_layout.itemAt(i)
            if item and item.widget() and isinstance(item.widget(), HistoryLabel):
                widget = item.widget()
                if widget != label_obj:
                    widget.set_selected(False)
        
        # ‡πÄ‡∏Å‡πá‡∏ö selected label ‡πÉ‡∏´‡∏°‡πà
        if label_obj.is_selected:
            self.selected_history_label = label_obj
            self.update_status(f"‡πÄ‡∏•‡∏∑‡∏≠‡∏Å history #{label_obj.sequence_number:02d}")
        else:
            self.selected_history_label = None
            self.update_status("‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å")
        
        # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏° delete
        self.update_delete_button_state()
    
    def delete_selected_history(self):
        """‡∏•‡∏ö history ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ß‡πâ (‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏° X ‡∏™‡∏µ‡πÅ‡∏î‡∏á)"""
        if not self.selected_history_label:
            return  # ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á
        
        # ‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å manager
        success = self.history_manager.remove_item(self.selected_history_label.item)
        if success:
            self.selected_history_label = None
            # Refresh display
            self.refresh_history_display()
            self.update_status("üóëÔ∏è ‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß")
            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏° delete
            self.update_delete_button_state()
        else:
            self.update_status("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÑ‡∏î‡πâ")
    
    def update_delete_button_state(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏° X (‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å)"""
        has_selection = self.selected_history_label is not None
        
        if hasattr(self, 'delete_history_btn'):
            self.delete_history_btn.setEnabled(has_selection)
            
            if has_selection:
                # ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏™‡∏î
                self.delete_history_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #5a2a2a;
                        color: #ff6666;
                        border: 1px solid #7a4a4a;
                        border-radius: 4px;
                        font-size: 12px;
                        font-weight: 600;
                        padding: 2px;
                    }
                    QPushButton:hover {
                        background-color: #7a3a3a;
                        color: #ff8888;
                        border-color: #9a5a5a;
                    }
                    QPushButton:pressed {
                        background-color: #6a2a2a;
                        color: #ffaaaa;
                    }
                """)
            else:
                # ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡∏™‡∏µ‡πÄ‡∏ó‡∏≤‡∏à‡∏≤‡∏á
                self.delete_history_btn.setStyleSheet("""
                    QPushButton:disabled {
                        background-color: #3a3a3a;
                        color: #666666;
                        border: 1px solid #4a4a4a;
                        border-radius: 4px;
                        font-size: 12px;
                        font-weight: 600;
                        padding: 2px;
                    }
                """)
    
    def delete_history_item(self, label_obj):
        """‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ history (hover 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ) - ‡πÄ‡∏Å‡πà‡∏≤ method ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏≠‡∏≠‡∏Å"""
        # ‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å manager
        success = self.history_manager.remove_item(label_obj.item)
        if success:
            # Clear focus ‡∏ñ‡πâ‡∏≤‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á focus ‡∏≠‡∏¢‡∏π‡πà
            if hasattr(self, 'focused_history_label') and self.focused_history_label == label_obj:
                self.focused_history_label = None
            
            # Refresh display
            self.refresh_history_display()
            self.update_status("üóëÔ∏è ‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß")
        else:
            self.update_status("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÑ‡∏î‡πâ")
    
    # ===== END HISTORY INTEGRATION =====
    
    def closeEvent(self, event):
        """Handle window close - cleanup resources including memory leak prevention"""
        try:
            # Cleanup all active images
            for image in self._active_images[:]:  # Copy list to avoid modification during iteration
                try:
                    image.close()
                except:
                    pass
            self._active_images.clear()
            
            # Clear pixmap cache
            self._pixmap_cache.clear()
            
            # IPC Server removed for standalone version
            # if hasattr(self, 'ipc_server') and self.ipc_server:
            #     self.ipc_server.stop()
            #     self.ipc_server.wait(2000)
            
            # ‡∏´‡∏¢‡∏∏‡∏î Worker thread
            if hasattr(self, 'worker') and self.worker and self.worker.isRunning():
                self.worker.terminate()
                self.worker.wait(2000)
            
            # ‡∏õ‡∏¥‡∏î floating viewer
            if hasattr(self, 'floating_viewer') and self.floating_viewer:
                self.floating_viewer.close()
                self.floating_viewer = None
            
            # ‡∏•‡∏ö temporary files
            if hasattr(self, 'temp_result_files'):
                for temp_file in self.temp_result_files:
                    try:
                        if os.path.exists(temp_file):
                            os.unlink(temp_file)
                            print(f"[FloatingViewer] Cleaned up temp file: {temp_file}")
                    except Exception as e:
                        print(f"[FloatingViewer] Error cleaning temp file {temp_file}: {e}")
                self.temp_result_files.clear()
            
            print("[BANANA] Cleanup completed with memory management")
            event.accept()
            
        except Exception as e:
            print(f"[BANANA] Error during close: {e}")
            event.accept()
    
    def create_left_panel(self) -> QFrame:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á Panel ‡∏ã‡πâ‡∏≤‡∏¢ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á thumbnail"""
        panel = QFrame()
        panel.setStyleSheet("""
            QFrame {
                background-color: #1f2e1f;
                border-right: 1px solid #304530;
            }
        """)
        
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        # ‡∏•‡∏ö‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏≠‡∏≠‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö
        
        # Select image button with icon
        self.select_btn = QPushButton("OPEN FOLDER")
        self.select_btn.clicked.connect(self.select_image)
        self.select_btn.setStyleSheet("""
            QPushButton {
                padding: 15px;
                font-size: 14px;
                font-weight: 600;
                background-color: #304530;
                color: #c8e6c9;
                border: 1px solid #608060;
            }
            QPushButton:hover {
                background-color: #3a5a3a;
                border: 1px solid #708070;
            }
            QPushButton:pressed {
                background-color: #253525;
            }
        """)
        layout.addWidget(self.select_btn)
        
        # üñºÔ∏è Multiple Start Images - 2x2 Slot Layout
        self.image_slots_widget = self.create_image_slots_widget()
        layout.addWidget(self.image_slots_widget, 1)  # stretch factor ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
        
        # Image info - ‡∏¢‡πà‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á
        self.image_info_label = QLabel("")
        self.image_info_label.setStyleSheet("""
            color: #9a9a9a;
            font-size: 10px;
            padding: 8px;
            background-color: #1a281a;
        """)
        self.image_info_label.setWordWrap(True)
        layout.addWidget(self.image_info_label, 0)  # ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ç‡∏¢‡∏≤‡∏¢
        
        layout.addStretch()
        return panel
    
    def create_image_slots_widget(self) -> QWidget:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á 2x2 Image Slots Layout ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Multiple Start Images"""
        
        # Main container
        container = QWidget()
        container.setStyleSheet("""
            QWidget {
                background-color: #1a281a;
                border: 2px dashed #405040;
                border-radius: 6px;
            }
        """)
        
        # 2x2 Grid Layout
        grid_layout = QGridLayout(container)
        grid_layout.setSpacing(8)  # ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á slots
        grid_layout.setContentsMargins(10, 10, 10, 10)
        
        # Create 4 image slots
        self.image_slots = []
        slot_positions = [(0, 0), (0, 1), (1, 0), (1, 1)]  # top-left, top-right, bottom-left, bottom-right
        
        for i, (row, col) in enumerate(slot_positions):
            slot_widget = self.create_single_image_slot(i + 1)  # slot numbers 1-4
            self.image_slots.append(slot_widget)
            grid_layout.addWidget(slot_widget, row, col)
        
        # Set equal stretch for all rows and columns
        grid_layout.setRowStretch(0, 1)
        grid_layout.setRowStretch(1, 1)
        grid_layout.setColumnStretch(0, 1)
        grid_layout.setColumnStretch(1, 1)
        
        return container
    
    def create_single_image_slot(self, slot_number: int) -> QWidget:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á slot ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö image ‡∏û‡∏£‡πâ‡∏≠‡∏° X button"""
        
        # Slot container
        slot_widget = QWidget()
        slot_widget.setMinimumSize(120, 120)
        slot_widget.setStyleSheet("""
            QWidget {
                background-color: #2a3a2a;
                border: 1px solid #405040;
                border-radius: 4px;
            }
            QWidget:hover {
                border: 1px solid #608060;
            }
        """)
        
        # Stack layout for overlay positioning
        layout = QVBoxLayout(slot_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Image label
        image_label = QLabel(f"Slot {slot_number}")
        image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        image_label.setScaledContents(False)  # ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° aspect ratio
        image_label.setStyleSheet("""
            QLabel {
                background-color: transparent;
                color: #889888;
                font-size: 11px;
                border: none;
                padding: 10px;
            }
        """)
        
        # Delete button (hidden by default)
        delete_btn = QPushButton("‚úï")
        delete_btn.setFixedSize(20, 20)
        delete_btn.setVisible(False)  # Hidden when no image
        delete_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: rgba(200, 200, 200, 0.8);
                border: none;
                font-size: 16px;
                font-weight: 900;
            }
            QPushButton:hover {
                color: rgba(255, 255, 255, 1.0);
                background-color: rgba(255, 255, 255, 0.1);
            }
        """)
        
        # Position delete button at top-right corner
        delete_btn.setParent(slot_widget)
        delete_btn.move(95, 5)  # Fixed position for 120px slot
        delete_btn.raise_()  # Bring to front
        
        # Connect delete button
        delete_btn.clicked.connect(lambda: self.remove_image_from_slot(slot_number - 1))
        
        # Store references
        image_label.delete_button = delete_btn
        image_label.slot_number = slot_number - 1  # 0-based index
        
        layout.addWidget(image_label)
        
        return slot_widget
    
    def create_center_panel(self) -> QFrame:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á Panel ‡∏Å‡∏•‡∏≤‡∏á ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏™‡πà prompt"""
        panel = QFrame()
        panel.setStyleSheet("""
            QFrame {
                background-color: #1f2e1f;
                border-right: 1px solid #304530;
            }
        """)
        
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(20, 15, 20, 20)  # ‡∏•‡∏î margin ‡∏ö‡∏ô‡πÉ‡∏´‡πâ‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ä‡∏¥‡∏î‡∏ö‡∏ô
        layout.setSpacing(10)  # ‡∏•‡∏î spacing ‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö‡∏Ç‡∏∂‡πâ‡∏ô
        
        # Header layout with title and floating editor button
        header_layout = QHBoxLayout()
        
        # Title
        title = QLabel("üìù Prompt")
        title.setFont(QFont("Segoe UI", 13, QFont.Weight.Bold))
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title.setStyleSheet("color: #c8e6c9; padding: 10px 0;")
        header_layout.addWidget(title, 1)
        
        
        layout.addLayout(header_layout)
        
        # ===== COLORS SETUP =====
        self.colors = {
            'components': '#1a281a',
            'borders': '#405040'
        }
        
        # ===== HISTORY SYSTEM SETUP =====
        # Initialize history manager
        self.history_manager = BananaHistoryManager()
        self.focused_history_label = None  # Track focused history item
        
        # Prompt input container with history panel
        self.prompt_container = QFrame()
        self.prompt_container.setStyleSheet("""
            QFrame {
                background-color: transparent;
                border: none;
            }
        """)
        prompt_main_layout = QVBoxLayout(self.prompt_container)
        prompt_main_layout.setContentsMargins(0, 0, 0, 0)
        prompt_main_layout.setSpacing(2)
        
        # === Text Editor Area with History Panel ===
        text_editor_layout = QHBoxLayout()
        text_editor_layout.setContentsMargins(0, 0, 0, 0)
        text_editor_layout.setSpacing(2)
        
        # === History Panel (‡∏î‡πâ‡∏≤‡∏ô‡∏ã‡πâ‡∏≤‡∏¢ - ‡πÅ‡∏ñ‡∏ö‡πÅ‡∏Ñ‡∏ö‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏û) ===
        self.history_panel = QWidget()
        self.history_panel.setFixedWidth(30)  # ‡πÅ‡∏Ñ‡∏ö‡∏°‡∏≤‡∏Å ‡πÅ‡∏Ñ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
        self.history_panel.setVisible(False)  # ‡∏ã‡πà‡∏≠‡∏ô‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥
        
        # History scroll area (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÄ‡∏¢‡∏≠‡∏∞)
        history_layout = QVBoxLayout(self.history_panel)
        history_layout.setContentsMargins(0, 0, 0, 0)
        history_layout.setSpacing(1)
        
        self.history_scroll = QScrollArea()
        self.history_scroll.setFixedWidth(28)
        self.history_scroll.setWidgetResizable(True)
        self.history_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.history_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.history_scroll.setStyleSheet("""
            QScrollArea {
                background-color: transparent;
                border: none;
            }
            QScrollBar:vertical {
                background-color: rgba(40, 40, 40, 100);
                width: 4px;
                border-radius: 2px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background-color: rgba(80, 80, 80, 150);
                border-radius: 2px;
                min-height: 20px;
            }
        """)
        
        # History content widget
        self.history_content = QWidget()
        self.history_layout = QVBoxLayout(self.history_content)
        self.history_layout.setSpacing(1)
        self.history_layout.setContentsMargins(2, 2, 2, 2)
        
        self.history_scroll.setWidget(self.history_content)
        history_layout.addWidget(self.history_scroll)
        
        # === Text Editor Area (‡∏î‡πâ‡∏≤‡∏ô‡∏Ç‡∏ß‡∏≤) ===
        text_editor_widget = QWidget()
        text_editor_layout_v = QVBoxLayout(text_editor_widget)
        text_editor_layout_v.setContentsMargins(0, 0, 0, 0)
        text_editor_layout_v.setSpacing(2)
        
        # === Button Bar (‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏Ç‡∏≠‡∏á text editor) ===
        button_bar = QHBoxLayout()
        button_bar.setContentsMargins(4, 2, 4, 2)
        button_bar.setSpacing(4)
        
        # Prompt label
        prompt_label = QLabel("üìù Prompt")
        prompt_label.setStyleSheet("color: #c8e6c9; font-weight: 500; font-size: 11px;")
        button_bar.addWidget(prompt_label)
        
        button_bar.addStretch()  # Push buttons to right
        
        # Action buttons (emoji only, no text) - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
        self.copy_prompt_btn = QPushButton("üìã")            # Copy
        self.add_to_history_btn = QPushButton("‚ûï")          # Add to history (manual only)
        self.delete_history_btn = QPushButton("‚ùå")         # Delete selected history (‡πÉ‡∏´‡∏°‡πà)
        self.clear_prompt_btn = QPushButton("üìÑ")           # Clear
        
        # Button styling
        button_style = f"""
            QPushButton {{
                background-color: {self.colors['components']};
                color: #c8e6c9;
                border: 1px solid {self.colors['borders']};
                border-radius: 4px;
                font-size: 12px;
                padding: 2px 4px;
            }}
            QPushButton:hover {{
                background-color: #3a5a3a;
                border-color: #5a7b5a;
            }}
            QPushButton:pressed {{
                background-color: #1a3a1a;
            }}
        """
        
        for btn in [self.copy_prompt_btn, self.add_to_history_btn, self.delete_history_btn, self.clear_prompt_btn]:
            btn.setFixedSize(28, 24)
            btn.setStyleSheet(button_style)
            button_bar.addWidget(btn)
        
        # Set tooltips
        self.copy_prompt_btn.setToolTip("Copy current prompt to clipboard")
        self.add_to_history_btn.setToolTip("Add current prompt to history (manual save)")
        self.delete_history_btn.setToolTip("Delete selected history item (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å history ‡∏Å‡πà‡∏≠‡∏ô)")
        self.clear_prompt_btn.setToolTip("Clear prompt text")
        
        # === Text Editor (‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏¥‡∏°) ===
        self.prompt_input = QTextEdit()
        self.prompt_input.setPlaceholderText(
            "‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà...\n‡πÄ‡∏ä‡πà‡∏ô: Add red pants, Remove hat, Create a cat on the beach..."
        )
        # ‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î maximum ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏•‡∏á‡πÑ‡∏î‡πâ
        self.prompt_input.setMinimumHeight(80)
        # ‡∏•‡∏ö setMaximumHeight ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ resize ‡∏•‡∏á‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î
        self.prompt_input.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)  # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô Expanding ‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏π‡πà
        self.prompt_input.textChanged.connect(self.update_ui_state)  # Update UI when text changes
        # Apply saved font size
        self.apply_font_size()
        self.prompt_input.setStyleSheet("""
            QTextEdit {
                background-color: #1a281a;
                border: 1px solid #405040;
                color: #c8e6c9;
                padding: 12px;
                font-family: 'Segoe UI';
                line-height: 1.4;
            }
            QTextEdit:focus {
                border: 1px solid #608060;
            }
            /* Resize handle styling */
            QTextEdit::corner {
                background-color: #405040;
            }
        """)
        
        # Assemble text editor area
        text_editor_layout_v.addLayout(button_bar)
        text_editor_layout_v.addWidget(self.prompt_input, 1)
        
        # Combine layouts
        text_editor_layout.addWidget(self.history_panel)     # ‡∏ã‡πâ‡∏≤‡∏¢ (‡∏ã‡πà‡∏≠‡∏ô‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥)
        text_editor_layout.addWidget(text_editor_widget, 1)  # ‡∏Ç‡∏ß‡∏≤ (‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà)
        
        # Add to main prompt layout
        prompt_main_layout.addLayout(text_editor_layout, 1)
        
        # Add custom resize handle for prompt box (using same icon as main resize)
        self.prompt_resize_handle = QLabel()
        self.prompt_resize_handle.setFixedSize(15, 15)  # Half size of main resize handle
        
        # Try to load resize.png icon
        resize_path = Path("resize.png")
        if resize_path.exists():
            pixmap = QPixmap(str(resize_path))
            if not pixmap.isNull():
                # Scale to half size (15x15 instead of 30x30)
                scaled_pixmap = pixmap.scaled(15, 15, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                self.prompt_resize_handle.setPixmap(scaled_pixmap)
            else:
                self.prompt_resize_handle.setText("‚ó¢")
        else:
            # Fallback to text if icon doesn't exist
            self.prompt_resize_handle.setText("‚ó¢")
        
        self.prompt_resize_handle.setStyleSheet("""
            QLabel {
                background-color: transparent;
                padding: 0px;
            }
            QLabel:hover {
                background-color: #405040;
                border-radius: 3px;
            }
        """)
        self.prompt_resize_handle.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.prompt_resize_handle.setCursor(Qt.CursorShape.SizeFDiagCursor)
        
        # Position handle at bottom-right of prompt container
        self.prompt_resize_handle.setParent(self.prompt_container)
        
        # Set initial height for prompt container
        self.prompt_container.setMinimumHeight(100)
        self.prompt_container.setMaximumHeight(300)  # Initial max height
        self.prompt_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        
        # Variables for prompt resize tracking
        self.prompt_resizing = False
        self.prompt_resize_start_pos = None
        self.prompt_resize_start_height = None
        
        # Image cache management for memory leak prevention
        self._active_images = []  # Keep track of PIL Images
        self._max_cache_size = 5  # Maximum cached images
        self._pixmap_cache = {}   # QPixmap cache with weak references
        
        # Install event filter for prompt resize handle
        self.prompt_resize_handle.installEventFilter(self)
        
        # Update handle position when container resizes
        self.prompt_container.resizeEvent = self.prompt_container_resize_event
        
        layout.addWidget(self.prompt_container, 0)  # ‡πÑ‡∏°‡πà auto-stretch ‡πÅ‡∏ï‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ resize ‡πÑ‡∏î‡πâ
        
        # Initial position for prompt resize handle
        QTimer.singleShot(0, lambda: self.prompt_container_resize_event(None))
        
        # ‡πÄ‡∏û‡∏¥‡πà‡∏° stretch space ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏±‡∏ô‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏á‡πÑ‡∏õ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏™‡∏°‡∏≠
        layout.addStretch(1)
        
        # Generation Mode Selection
        mode_layout = QVBoxLayout()
        
        # Mode title
        mode_title = QLabel("üé® Generation Mode:")
        mode_title.setStyleSheet("""
            QLabel {
                color: #c8e6c9;
                font-size: 14px;
                font-weight: 600;
                margin-bottom: 10px;
                margin-top: 15px;
            }
        """)
        mode_layout.addWidget(mode_title)
        
        # First row: Image-to-Image (requires image)
        img_to_img_layout = QHBoxLayout()
        self.img_to_img_btn = QPushButton("üçå ‡πÅ‡∏ï‡πà‡∏á‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢-BANANA")
        self.img_to_img_btn.setToolTip("‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢ Banana Editor (Gemini 2.5 Flash)")
        self.img_to_img_btn.clicked.connect(lambda: self.start_generation("image_to_image"))
        self.img_to_img_btn.setStyleSheet(self.get_button_style("primary"))
        img_to_img_layout.addWidget(self.img_to_img_btn)
        mode_layout.addLayout(img_to_img_layout)
        
        # Second row: Text-to-Image buttons with aspect ratio on same line
        buttons_layout = QHBoxLayout()
        
        # Text-to-Image Button  
        self.txt_to_img_btn = QPushButton("üìù ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û")
        self.txt_to_img_btn.setToolTip("‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡πâ‡∏ß‡∏¢ Gemini 2.5 Flash")
        self.txt_to_img_btn.clicked.connect(lambda: self.start_generation("text_to_image"))
        self.txt_to_img_btn.setStyleSheet(self.get_button_style("secondary"))
        
        # Imagen-4 Button (high quality)
        self.imagen4_btn = QPushButton("‚ú® ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û-HD")
        self.imagen4_btn.setToolTip("‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏î‡πâ‡∏ß‡∏¢ Imagen 4.0 (‡∏ä‡πâ‡∏≤‡πÅ‡∏ï‡πà‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)")
        self.imagen4_btn.clicked.connect(lambda: self.start_generation("imagen4"))
        self.imagen4_btn.setStyleSheet(self.get_button_style("premium"))
        
        # Aspect ratio dropdown (compact version)
        # QComboBox already imported
        self.aspect_combo = QComboBox()
        self.aspect_combo.addItems([
            "1:1",      # ‡∏•‡∏ö‡πÄ‡∏ó‡πá‡∏Å‡∏ã‡πå‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ç‡∏≠
            "16:9", 
            "9:16",
            "4:3",
            "3:4"
        ])
        self.aspect_combo.setCurrentText("1:1")
        self.aspect_combo.setMaximumWidth(80)  # ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Å‡∏•‡πà‡∏≠‡∏á‡πÅ‡∏Ñ‡∏ö‡∏•‡∏á
        self.aspect_combo.setStyleSheet("""
            QComboBox {
                padding: 8px 6px;
                background-color: #304530;
                color: #c8e6c9;
                border: 1px solid #405040;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 500;
            }
            QComboBox:drop-down {
                border: none;
                background-color: #405040;
                width: 20px;
            }
            QComboBox:down-arrow {
                border: 1px solid #608060;
            }
        """)
        
        # Batch count dropdown (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏†‡∏≤‡∏û 1-4)
        self.batch_combo = QComboBox()
        self.batch_combo.addItems(["1-img", "2-img", "3-img", "4-img"])
        self.batch_combo.setCurrentText("1-img")
        self.batch_combo.setMaximumWidth(70)
        self.batch_combo.setStyleSheet("""
            QComboBox {
                padding: 8px 6px;
                background-color: #304530;
                color: #c8e6c9;
                border: 1px solid #405040;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 500;
            }
            QComboBox:drop-down {
                border: none;
            }
            QComboBox:down-arrow {
                border: 1px solid #608060;
            }
        """)
        
        # Create layout for dropdowns (aspect ratio ‡∏ö‡∏ô, batch count ‡∏•‡πà‡∏≤‡∏á)
        dropdown_layout = QVBoxLayout()
        dropdown_layout.setSpacing(4)
        dropdown_layout.addWidget(self.aspect_combo)
        dropdown_layout.addWidget(self.batch_combo)
        
        # Add widgets to buttons layout
        buttons_layout.addWidget(self.txt_to_img_btn)
        buttons_layout.addWidget(self.imagen4_btn)
        buttons_layout.addLayout(dropdown_layout)  # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å widget ‡πÄ‡∏õ‡πá‡∏ô layout
        
        mode_layout.addLayout(buttons_layout)  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        layout.addLayout(mode_layout)
        
        # [REMOVED] Duplicate progress_bar - using the one from main layout
        
        # [REMOVED] Save results button - ‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£ save ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
        
        return panel
    
    def create_right_panel(self) -> QFrame:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á Panel ‡∏Ç‡∏ß‡∏≤ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå - ‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ö left panel"""
        panel = QFrame()
        panel.setStyleSheet("""
            QFrame {
                background-color: #1f2e1f;
                border-left: 1px solid #304530;
            }
        """)
        
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        # ‡∏•‡∏ö‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏≠‡∏≠‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö
        
        # ‡∏†‡∏≤‡∏û‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå - ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô thumbnail ‡πÉ‡∏ô left panel
        self.result_image_label = QLabel("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå")
        self.result_image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.result_image_label.setScaledContents(False)  # ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° aspect ratio
        self.result_image_label.setStyleSheet("""
            QLabel {
                border: 2px dashed #405040;
                padding: 5px;
                background-color: #1a281a;
                min-height: 400px;
                color: #889888;
                font-size: 13px;
            }
        """)
        layout.addWidget(self.result_image_label, 1)  # stretch factor ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ç‡∏¢‡∏≤‡∏¢‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
        
        # Result image info - ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô left panel
        self.result_info_label = QLabel("")
        self.result_info_label.setStyleSheet("""
            color: #9a9a9a;
            font-size: 10px;
            padding: 8px;
            background-color: #1a281a;
        """)
        self.result_info_label.setWordWrap(True)
        layout.addWidget(self.result_info_label, 0)  # ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ç‡∏¢‡∏≤‡∏¢
        
        layout.addStretch()  # ‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡πà‡∏ß‡∏ô‡∏•‡πà‡∏≤‡∏á
        
        # Save location toggle button (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        self.save_location_button = QPushButton("SAVE ON ORIGINAL FOLDER")
        self.save_location_button.clicked.connect(self.on_save_location_toggle)
        self.save_location_button.setStyleSheet("""
            QPushButton {
                background-color: #b8860b;
                color: #2d2d2d;
                border: 2px solid #d4af37;
                border-radius: 6px;
                padding: 8px 16px;
                font-size: 10px;
                font-weight: bold;
                min-width: 160px;
            }
            QPushButton:hover {
                background-color: #d4af37;
                border-color: #ffd700;
            }
            QPushButton:pressed {
                background-color: #9a7c0a;
                border-color: #b8860b;
            }
        """)
        
        button_layout.addWidget(self.save_location_button)
        button_layout.addStretch()
        layout.addLayout(button_layout)
        
        return panel
    
    def check_environment(self):
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏°"""
        api_key = os.getenv('GEMINI_API_KEY')
        
        # Check if .env file exists
        env_file = Path('.env')
        env_exists = env_file.exists()
        
        if not api_key:
            env_help = ""
            if env_exists:
                env_help = "\n\n‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏™‡πà‡πÉ‡∏ô .env file:\nGEMINI_API_KEY=your_api_key_here"
            else:
                env_help = "\n\n‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .env:\nGEMINI_API_KEY=your_api_key_here"
            
            self.update_status("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö GEMINI_API_KEY")
            QMessageBox.warning(
                self, 
                "‡πÑ‡∏°‡πà‡∏û‡∏ö API Key",
                f"‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ GEMINI_API_KEY\n\n"
                f"‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà 1 - Environment Variables:\n"
                f"Windows: set GEMINI_API_KEY=your_api_key_here\n"
                f"Linux/Mac: export GEMINI_API_KEY=your_api_key_here"
                f"{env_help}"
            )
        else:
            status_msg = "‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡∏û‡∏ö API Key ‡πÅ‡∏•‡πâ‡∏ß"
            if env_exists:
                status_msg += " (‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å .env)"
            self.update_status(status_msg)
    
    def update_status(self, message: str):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.status_label.setText(f"[{timestamp}] {message}")
    
    def save_single_result(self, image, index):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß"""
        try:
            # ‡πÉ‡∏ä‡πâ save location toggle setting
            if hasattr(self, 'save_on_original') and not self.save_on_original:
                save_dir = Path.cwd() / "banana_results"
                save_dir.mkdir(exist_ok=True)
            else:
                # Save to original folder
                if hasattr(self, 'current_image_path') and self.current_image_path:
                    save_dir = Path(self.current_image_path).parent
                else:
                    # Default: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå banana ‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
                    save_dir = Path.cwd() / "banana"
                    save_dir.mkdir(exist_ok=True)
            
            # Generate filename using new naming system
            now = datetime.now()
            date_str = f"{now.day}{now.strftime('%b').lower()}"  # 1sep, 2oct, etc.
            start_number = self.get_next_file_number(save_dir, date_str)
            filename = f"banana_{date_str}_{start_number + index:03d}.png"
            file_path = save_dir / filename
            
            # Safety check for file collision
            counter = 0
            while file_path.exists() and counter < 1000:
                counter += 1
                filename = f"banana_{date_str}_{start_number + index + counter:03d}.png"
                file_path = save_dir / filename
            
            # Save image
            image.save(str(file_path), "PNG")
            
            self.update_status(f"‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà {index+1} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {file_path.name}")
            
        except Exception as e:
            self.update_status(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà {index+1} ‡πÑ‡∏î‡πâ: {e}")
    
    def on_save_location_toggle(self):
        """‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å"""
        # ‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
        self.save_on_original = not self.save_on_original
        
        # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏™‡∏µ‡∏ö‡∏ô‡∏õ‡∏∏‡πà‡∏°‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        if self.save_on_original:
            # Original folder - ‡∏™‡∏µ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á
            self.save_location_button.setText("SAVE ON ORIGINAL FOLDER")
            self.save_location_button.setStyleSheet("""
                QPushButton {
                    background-color: #b8860b;
                    color: #2d2d2d;
                    border: 2px solid #d4af37;
                    border-radius: 6px;
                    padding: 8px 16px;
                    font-size: 10px;
                    font-weight: bold;
                    min-width: 160px;
                }
                QPushButton:hover {
                    background-color: #daa520;
                    border-color: #ffd700;
                    color: #1a1a1a;
                }
                QPushButton:pressed {
                    background-color: #9a7c0a;
                    border-color: #b8860b;
                }
            """)
        else:
            # Banana folder - ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏™‡∏ß‡πà‡∏≤‡∏á
            self.save_location_button.setText("SAVE ON BANANA FOLDER")
            self.save_location_button.setStyleSheet("""
                QPushButton {
                    background-color: #4a7c59;
                    color: #e8f5e8;
                    border: 2px solid #5a8c69;
                    border-radius: 6px;
                    padding: 8px 16px;
                    font-size: 10px;
                    font-weight: bold;
                    min-width: 160px;
                }
                QPushButton:hover {
                    background-color: #5a8c69;
                    border-color: #6a9c79;
                    color: #ffffff;
                }
                QPushButton:pressed {
                    background-color: #3a6c49;
                    border-color: #4a7c59;
                }
            """)
    
    def mousePressEvent(self, event):
        """Handle mouse press for window dragging and resizing"""
        if event.button() == Qt.MouseButton.LeftButton:
            pos = event.position().toPoint()
            if self.is_in_resize_area(pos):
                # Start resizing
                self.resize_drag = True
                self.resize_start_pos = event.globalPosition().toPoint()
                self.resize_start_geometry = self.geometry()
                event.accept()
            else:
                # Start dragging
                self.drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                event.accept()
    
    def mouseMoveEvent(self, event):
        """Handle mouse move for window dragging and resizing"""
        if self.resize_drag and event.buttons() == Qt.MouseButton.LeftButton:
            # Handle resizing
            if self.resize_start_pos and self.resize_start_geometry:
                diff = event.globalPosition().toPoint() - self.resize_start_pos
                new_width = max(800, self.resize_start_geometry.width() + diff.x())
                new_height = max(500, self.resize_start_geometry.height() + diff.y())
                self.resize(new_width, new_height)
            event.accept()
        elif event.buttons() == Qt.MouseButton.LeftButton and self.drag_position:
            # Handle dragging
            self.move(event.globalPosition().toPoint() - self.drag_position)
            event.accept()
        else:
            # Check if mouse is over resize area
            pos = event.position().toPoint()
            if self.is_in_resize_area(pos):
                self.setCursor(Qt.CursorShape.SizeFDiagCursor)
            else:
                self.setCursor(Qt.CursorShape.ArrowCursor)
    
    def mouseReleaseEvent(self, event):
        """Handle mouse release for window dragging and resizing"""
        self.drag_position = None
        self.resize_drag = False
        self.resize_start_pos = None
        self.resize_start_geometry = None
        self.setCursor(Qt.CursorShape.ArrowCursor)
    
    def setup_shortcuts(self):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ keyboard shortcuts"""
        # QShortcut, QKeySequence already imported
        
        # Ctrl+V for paste from clipboard (4-slot system)
        paste_shortcut = QShortcut(QKeySequence("Ctrl+V"), self)
        paste_shortcut.activated.connect(self.paste_from_clipboard)
        
        # Ctrl+P for paste from clipboard (alternative shortcut)
        paste_shortcut_p = QShortcut(QKeySequence("Ctrl+P"), self)
        paste_shortcut_p.activated.connect(self.paste_from_clipboard)
        
        # Ctrl+Enter for triggering GEN-AI button
        generate_shortcut = QShortcut(QKeySequence("Ctrl+Return"), self)
        generate_shortcut.activated.connect(self.trigger_gen_ai)
        
        # Alternative Ctrl+Enter
        generate_shortcut2 = QShortcut(QKeySequence("Ctrl+Enter"), self)
        generate_shortcut2.activated.connect(self.trigger_gen_ai)
        
        # Note: Ctrl+Scroll for font size adjustment is handled in wheelEvent
        
    
    def get_button_style(self, button_type: str) -> str:
        """Get button stylesheet based on type"""
        base_style = """
            QPushButton {
                padding: 15px;
                font-size: 14px;
                font-weight: bold;
                border: 2px solid;
                border-radius: 8px;
                min-height: 20px;
            }
            QPushButton:hover {
                margin-top: 1px;
            }
            QPushButton:pressed {
                margin-top: 0px;
            }
            QPushButton:disabled {
                opacity: 0.4;
                background-color: #2a2a2a;
                color: #666;
                border-color: #444;
            }
        """
        
        if button_type == "primary":  # IMG-TO-IMG - ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡πÄ‡∏Ç‡πâ‡∏°
            return base_style + """
                QPushButton:enabled {
                    background-color: #2d5a2d;
                    color: #c8e6c9;
                    border-color: #4a7c4a;
                }
                QPushButton:enabled:hover {
                    background-color: #3d6a3d;
                    border-color: #5a8c5a;
                }
            """
        elif button_type == "secondary":  # TXT-TO-IMG - ‡∏™‡∏µ‡∏ü‡πâ‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß
            return base_style + """
                QPushButton:enabled {
                    background-color: #2d4a5a;
                    color: #c8d6e6;
                    border-color: #4a6c7c;
                }
                QPushButton:enabled:hover {
                    background-color: #3d5a6a;
                    border-color: #5a7c8c;
                }
            """
        elif button_type == "premium":  # IMAGEN-4 - ‡∏™‡∏µ‡∏ó‡∏≠‡∏á
            return base_style + """
                QPushButton:enabled {
                    background-color: #5a4a2d;
                    color: #f0e6c8;
                    border-color: #7c6c4a;
                }
                QPushButton:enabled:hover {
                    background-color: #6a5a3d;
                    border-color: #8c7c5a;
                }
            """
        else:
            return base_style
    
    def update_ui_state(self):
        """Update UI state based on current conditions"""
        has_image = bool(self.selected_image_path and os.path.exists(self.selected_image_path))
        has_prompt = bool(self.prompt_input.toPlainText().strip())
        
        # IMG-TO-IMG: ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ó‡∏±‡πâ‡∏á‡∏†‡∏≤‡∏û‡πÅ‡∏•‡∏∞ prompt
        if has_image and has_prompt:
            self.img_to_img_btn.setEnabled(True)
            self.img_to_img_btn.setToolTip("‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏ß‡∏¢ Gemini 2.5 Flash")
        elif not has_image:
            self.img_to_img_btn.setEnabled(False)
            self.img_to_img_btn.setToolTip("‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡∏Å‡πà‡∏≠‡∏ô (Drag & Drop ‡∏´‡∏£‡∏∑‡∏≠ Paste)")
        else:  # no prompt
            self.img_to_img_btn.setEnabled(False)
            self.img_to_img_btn.setToolTip("‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç")
        
        # TXT-TO-IMG ‡πÅ‡∏•‡∏∞ IMAGEN-4: ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÅ‡∏Ñ‡πà prompt
        if has_prompt:
            self.txt_to_img_btn.setEnabled(True)
            self.txt_to_img_btn.setToolTip("‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡πâ‡∏ß‡∏¢ Gemini 2.5 Flash")
            
            self.imagen4_btn.setEnabled(True)
            self.imagen4_btn.setToolTip("‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏î‡πâ‡∏ß‡∏¢ Imagen 4.0 (‡∏ä‡πâ‡∏≤‡πÅ‡∏ï‡πà‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)")
        else:
            self.txt_to_img_btn.setEnabled(False)
            self.txt_to_img_btn.setToolTip("‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£")
            
            self.imagen4_btn.setEnabled(False) 
            self.imagen4_btn.setToolTip("‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£")
        
        # Update status based on state
        if has_image and has_prompt:
            self.update_status("‚úÖ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡πÇ‡∏´‡∏°‡∏î | ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á")
        elif has_image:
            self.update_status("üìù ‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç")
        elif has_prompt:
            self.update_status("üé® ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà | ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å TXT-TO-IMG ‡∏´‡∏£‡∏∑‡∏≠ IMAGEN-4")
        else:
            self.update_status("üìÇ Drag & Drop ‡∏†‡∏≤‡∏û ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô")
    
    def start_generation(self, mode: str):
        """Start generation based on selected mode"""
        prompt = self.prompt_input.toPlainText().strip()
        
        if not prompt:
            self.update_status("‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡πà‡∏≠‡∏ô")
            return
        
        # ‡∏•‡πâ‡∏≤‡∏á temp_result_files ‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô FloatingImageViewer ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏¥‡∏î
        if hasattr(self, 'temp_result_files'):
            self.temp_result_files.clear()
            print("[GENERATION] Cleared temp_result_files from previous session")
        
        if mode == "image_to_image":
            if not self.selected_image_path or not os.path.exists(self.selected_image_path):
                self.update_status("‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡∏Å‡πà‡∏≠‡∏ô")
                return
            
            # Get batch count for Banana editing
            batch_count = self.get_batch_count()
            
            if batch_count == 1:
                # Single image editing - ‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°
                self.update_status("üçå ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡∏î‡πâ‡∏ß‡∏¢ Gemini 2.5 Flash...")
                self.start_editing(use_new_sdk=True)
            else:
                # Batch image editing - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
                self.update_status(f"üçå ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á {batch_count} variations ‡∏î‡πâ‡∏ß‡∏¢ Banana Editor...")
                self.start_batch_image_editing(batch_count)
            
        elif mode == "text_to_image":
            self.update_status("üé® ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà‡∏î‡πâ‡∏ß‡∏¢ Gemini 2.5 Flash...")
            self.start_text_to_image_generation(use_gemini=True)
            
        elif mode == "imagen4":
            self.update_status("‚ú® ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏î‡πâ‡∏ß‡∏¢ Imagen 4.0...")
            # ‡πÅ‡∏™‡∏î‡∏á progress bar ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Imagen-4 ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö text-to-image ‡∏≠‡∏∑‡πà‡∏ô‡πÜ
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setVisible(True)
                self.progress_bar.setRange(0, 0)  # Indeterminate progress
                self.progress_bar.setValue(0)  # Reset value
            self.start_text_to_image_generation(use_gemini=False)
    
    def trigger_gen_ai(self):
        """‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏õ‡∏∏‡πà‡∏° IMG-TO-IMG ‡∏ú‡πà‡∏≤‡∏ô hotkey"""
        if self.img_to_img_btn.isEnabled():
            self.start_generation("image_to_image")
    
    
    
    def get_batch_count(self) -> int:
        """Get number of images to generate from batch combo"""
        batch_text = self.batch_combo.currentText()
        return int(batch_text.split('-')[0])  # Extract number from "1-img", "2-img", etc.
    
    def get_aspect_ratio(self) -> str:
        """Convert aspect ratio from combo box to API format"""
        combo_text = self.aspect_combo.currentText()
        if "1:1" in combo_text:
            return "1:1"
        elif "16:9" in combo_text:
            return "16:9" 
        elif "9:16" in combo_text:
            return "9:16"
        elif "4:3" in combo_text:
            return "4:3"
        elif "3:4" in combo_text:
            return "3:4"
        else:
            return "1:1"  # Default
    
    def start_text_to_image_generation(self, use_gemini: bool = True):
        """Start Text-to-Image generation with batch support"""
        prompt = self.prompt_input.toPlainText().strip()
        if not prompt:
            self.update_status("‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£")
            return
            
        # Get parameters
        aspect_ratio = self.get_aspect_ratio()
        batch_count = self.get_batch_count()
            
        # Disable all buttons during generation
        self.set_buttons_enabled(False)
        
        # Initialize batch tracking
        self.batch_workers = []
        self.batch_results = []
        self.completed_workers = 0
        self.total_workers = batch_count
        
        # Setup progress bar for batch generation
        if hasattr(self, 'progress_bar'):
            self.progress_bar.setVisible(True)
            if batch_count > 1:
                self.progress_bar.setRange(0, batch_count)  # Determinate progress for batch
                self.progress_bar.setValue(0)
            else:
                self.progress_bar.setRange(0, 0)  # Indeterminate for single image
        
        status_text = f"üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏£‡πâ‡∏≤‡∏á {batch_count} ‡∏†‡∏≤‡∏û‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô..."
        self.update_status(status_text)
        
        # Create multiple workers for concurrent generation
        for i in range(batch_count):
            worker = TextToImageWorker(prompt, use_gemini, aspect_ratio)
            worker.images_generated.connect(self.on_batch_worker_complete)
            worker.error_occurred.connect(self.on_batch_worker_error)
            worker.status_update.connect(lambda msg, idx=i: self.update_status(f"Worker {idx+1}: {msg}"))
            
            self.batch_workers.append(worker)
            worker.start()  # Start immediately for concurrent processing
    
    def start_batch_image_editing(self, batch_count: int):
        """Start batch Image-to-Image editing (multiple variations from single image)"""
        prompt = self.prompt_input.toPlainText().strip()
        
        # Disable all buttons during generation
        self.set_buttons_enabled(False)
        
        # Initialize batch tracking
        self.batch_workers = []
        self.batch_results = []
        self.completed_workers = 0
        self.total_workers = batch_count
        
        # Setup progress bar for batch generation
        if hasattr(self, 'progress_bar'):
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, batch_count)  # Determinate progress for batch
            self.progress_bar.setValue(0)
        
        # Prepare image content for editing
        try:
            from PIL import Image
            with Image.open(self.selected_image_path) as img:
                if img.mode != 'RGB':
                    img = img.convert('RGB')
                
                # Resize if needed
                max_size = 1024
                if max(img.size) > max_size:
                    img.thumbnail((max_size, max_size), Image.Resampling.LANCZOS)
                
                # Create multiple workers for concurrent editing
                for i in range(batch_count):
                    # Each worker gets the same prompt and image but may produce different results
                    contents = [prompt, img.copy()]  # [prompt, PIL.Image]
                    
                    worker = ImageEditWorker(contents, use_new_sdk=True)
                    worker.finished.connect(self.on_batch_worker_complete)
                    worker.error.connect(self.on_batch_worker_error)
                    worker.status_update.connect(lambda msg, idx=i: self.update_status(f"Worker {idx+1}: {msg}"))
                    
                    self.batch_workers.append(worker)
                    worker.start()  # Start immediately for concurrent processing
                    
        except Exception as e:
            self.update_status(f"‚ùå Error preparing batch editing: {str(e)}")
            self.set_buttons_enabled(True)
    
    def on_batch_worker_complete(self, image_data_list: list):
        """Handle completion of one worker in batch generation"""
        print(f"[WORKER-COMPLETE] Worker finished with {len(image_data_list)} images")
        self.completed_workers += 1
        self.batch_results.extend(image_data_list)
        print(f"[WORKER-COMPLETE] Total results now: {len(self.batch_results)}")
        
        # Update progress bar
        if hasattr(self, 'progress_bar') and self.total_workers > 1:
            self.progress_bar.setValue(self.completed_workers)
        
        progress_text = f"‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß {self.completed_workers}/{self.total_workers} ‡∏á‡∏≤‡∏ô"
        self.update_status(progress_text)
        
        # Check if all workers are done
        if self.completed_workers >= self.total_workers:
            self.on_all_batch_workers_complete()
    
    def on_batch_worker_error(self, error_message: str):
        """Handle error from one worker in batch generation"""
        try:
            print("[BATCH-ERROR] Worker error:", str(error_message)[:100])
        except:
            print("[BATCH-ERROR] Worker error (encoding issue)")
        self.completed_workers += 1
        
        # Update progress bar even on error
        if hasattr(self, 'progress_bar') and self.total_workers > 1:
            self.progress_bar.setValue(self.completed_workers)
        
        # Continue even if some workers fail
        progress_text = f"‚ö†Ô∏è {self.completed_workers}/{self.total_workers} ‡∏á‡∏≤‡∏ô (‡∏°‡∏µ error)"
        self.update_status(progress_text)
        
        if self.completed_workers >= self.total_workers:
            self.on_all_batch_workers_complete()
    
    def on_all_batch_workers_complete(self):
        """Handle completion of all batch workers"""
        try:
            # Hide progress bar safely
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setVisible(False)
            
            self.results = self.batch_results
            
            # üõ†Ô∏è MIXED RESULTS FIX: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏ô memory ‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏à‡∏£‡∏¥‡∏á
            saved_files = []
            has_api_results = bool(self.batch_results)
            print(f"[BATCH-COMPLETE] has_api_results={has_api_results}, batch_results_count={len(self.batch_results)}")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏à‡∏£‡∏¥‡∏á‡πÜ (‡∏Å‡∏£‡∏ì‡∏µ API error ‡πÅ‡∏ï‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏î‡πâ)
            if hasattr(self, 'selected_image_path') and self.selected_image_path:
                saved_files = self._check_saved_files()
                print(f"[BATCH-COMPLETE] Found {len(saved_files)} saved files")
            
            if has_api_results:
                # ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏≤‡∏Å API memory
                print(f"[BATCH-COMPLETE] Calling display_results with {len(self.batch_results)} results")
                self.display_results(self.batch_results)
                
                # Auto-save for all generated images
                self.auto_save_results(self.batch_results)
                location = "‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö" if (self.save_on_original and hasattr(self, 'selected_image_path') and self.selected_image_path) else "‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå banana"
                self.update_status(f"‚úÖ ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û {len(self.batch_results)} ‡∏†‡∏≤‡∏û ‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÉ‡∏ô{location}‡πÅ‡∏•‡πâ‡∏ß")
                    
            elif saved_files:
                # üéØ ‡∏Å‡∏£‡∏ì‡∏µ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: API error ‡πÅ‡∏ï‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏à‡∏£‡∏¥‡∏á - ‡πÅ‡∏™‡∏î‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏ó‡∏ô mock
                self._display_saved_files_as_results(saved_files)
                success_count = len(saved_files)
                failed_count = self.total_workers - success_count
                location = "‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö" if self.save_on_original else "‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå banana"
                self.update_status(f"‚ö†Ô∏è ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÅ‡∏ö‡∏ö‡∏ú‡∏™‡∏°: ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à {success_count}/{self.total_workers} ‡∏†‡∏≤‡∏û (‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÉ‡∏ô{location}‡πÅ‡∏•‡πâ‡∏ß)")
                
            else:
                # ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ó‡∏±‡πâ‡∏á API results ‡πÅ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å - ‡πÅ‡∏™‡∏î‡∏á error ‡πÅ‡∏•‡∏∞ mock thumbnails
                error_count = self.total_workers
                self.update_status(f"‚ùå Generation failed - {error_count}/{self.total_workers} workers failed (likely API blocked by safety filters)")
                
                # ‡πÅ‡∏™‡∏î‡∏á mock thumbnails ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ
                if self.total_workers > 1:
                    self.test_display_mock_results()
                
        except Exception as e:
            self.update_status(f"‚ùå Error displaying results: {str(e)}")
        
        # Cleanup batch workers
        self.batch_workers = []
        self.batch_results = []
        self.completed_workers = 0
        self.total_workers = 0
        
        self.set_buttons_enabled(True)

    def set_buttons_enabled(self, enabled: bool):
        """Enable/disable all generation buttons"""
        self.img_to_img_btn.setEnabled(enabled)
        self.txt_to_img_btn.setEnabled(enabled)
        self.imagen4_btn.setEnabled(enabled)
        
        # Show/hide progress bar
        self.progress_bar.setVisible(not enabled)
        
        if enabled:
            # Re-evaluate button states
            self.update_ui_state()
    
    def test_display_mock_results(self):
        """‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö: ‡πÉ‡∏ä‡πâ error.png ‡πÄ‡∏õ‡πá‡∏ô mock thumbnails ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏™‡∏µ"""
        try:
            # ‡πÉ‡∏ä‡πâ error.png ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ó‡∏ô
            error_png_path = Path("error.png")
            if not error_png_path.exists():
                print("[MOCK] error.png not found, skipping mock display")
                return
                
            # ‡∏≠‡πà‡∏≤‡∏ô error.png ‡πÄ‡∏õ‡πá‡∏ô bytes
            with open(error_png_path, 'rb') as f:
                error_png_bytes = f.read()
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á mock results ‡∏î‡πâ‡∏ß‡∏¢ error.png ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô total_workers
            mock_results = [error_png_bytes] * self.total_workers
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• mock results
            if mock_results:
                self.display_results(mock_results)
                self.update_status(f"‚ùå API generation failed - ‡πÅ‡∏™‡∏î‡∏á {len(mock_results)} error thumbnails")
                
        except Exception as e:
            print(f"Error in test_display_mock_results: {str(e)}")

    def on_generation_complete(self, image_data_list: list):
        """Handle successful generation completion (both Text-to-Image and Image-to-Image)"""
        print(f"[GENERATION-COMPLETE] Called with {len(image_data_list) if image_data_list else 0} images")
        try:
            # Hide progress bar safely
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setVisible(False)
            self.results = image_data_list
            
            if image_data_list:
                print(f"[GENERATION-COMPLETE] Calling display_results with {len(image_data_list)} images")
                self.display_results(image_data_list)
                
                # Auto-save for all generated images
                self.auto_save_results(image_data_list)
                location = "‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö" if (self.save_on_original and hasattr(self, 'selected_image_path') and self.selected_image_path) else "‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå banana"
                self.update_status(f"‚úÖ ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û {len(image_data_list)} ‡∏†‡∏≤‡∏û ‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÉ‡∏ô{location}‡πÅ‡∏•‡πâ‡∏ß")
                
                # [REMOVED] save_btn.setEnabled(True) - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß
            else:
                self.update_status("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏≤‡∏Å API")
            
            self.set_buttons_enabled(True)
            
        except Exception as e:
            print(f"Error in on_generation_complete: {e}")  # Debug print
            self.on_generation_error(f"Error displaying results: {str(e)}")
    
    def on_generation_error(self, error_message: str):
        """Handle generation error (both Text-to-Image and Image-to-Image)"""
        try:
            print("[GENERATION-ERROR] Error occurred:", str(error_message)[:100])
        except:
            print("[GENERATION-ERROR] Error occurred (encoding issue)")
        
        # ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û error ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ú‡∏™‡∏°
        self.show_error_image()
        
        # ‡∏•‡πâ‡∏≤‡∏á temp_result_files ‡πÅ‡∏•‡∏∞ last_result_path ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ú‡∏¥‡∏î
        if hasattr(self, 'temp_result_files'):
            self.temp_result_files.clear()
            
        if hasattr(self, 'last_result_path'):
            self.last_result_path = None
        
        # Hide progress bar safely
        if hasattr(self, 'progress_bar'):
            self.progress_bar.setVisible(False)
        self.set_buttons_enabled(True)
        
        # ‡πÅ‡∏õ‡∏• error ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏Ñ‡∏ô‡πÑ‡∏î‡πâ
        translated_error = self.translate_error(error_message)
        
        self.update_status(f"‚ùå {translated_error['title']}")
        
        # ‡πÅ‡∏™‡∏î‡∏á error button ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
        self.error_button.setText(f"{translated_error['title']} - ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç")
        self.error_button.setVisible(True)
        
        # Store error information
        self.last_error = error_message
        self.last_translated_error = translated_error

    def paste_from_clipboard(self):
        """Paste image from clipboard - 4-slot system compatible (Ctrl+V, Ctrl+P)"""
        try:
            # QGuiApplication already imported
            clipboard = QGuiApplication.clipboard()
            mime_data = clipboard.mimeData()
            
            if mime_data.hasImage():
                # Get image from clipboard
                pixmap = clipboard.pixmap()
                if not pixmap.isNull():
                    # Save to temporary file
                    import tempfile
                    temp_file = tempfile.NamedTemporaryFile(suffix='.png', delete=False)
                    pixmap.save(temp_file.name, 'PNG')
                    
                    # üÜï 4-Slot System: Add to next available slot
                    success = self.add_image_to_next_available_slot(temp_file.name)
                    if success:
                        self.update_status("‚úÖ ‡∏ß‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å Clipboard ‡πÄ‡∏Ç‡πâ‡∏≤ slot ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ")
                    else:
                        # Fallback: Replace slot 1 if all slots full
                        self.image_paths[0] = temp_file.name
                        self.update_slot_display(0)
                        self.update_image_info()
                        self.update_status("‚úÖ ‡∏ß‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å Clipboard ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà slot 1 (slots ‡πÄ‡∏ï‡πá‡∏°)")
                    
                    self.update_ui_state()  # Update button states
                    return
            
            if mime_data.hasUrls():
                urls = mime_data.urls()
                if urls:
                    file_path = urls[0].toLocalFile()
                    if self.is_image_file(file_path):
                        # üÜï 4-Slot System: Add to next available slot
                        success = self.add_image_to_next_available_slot(file_path)
                        if success:
                            self.update_status(f"‚úÖ ‡∏ß‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å Clipboard: {Path(file_path).name} ‡πÄ‡∏Ç‡πâ‡∏≤ slot ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ")
                        else:
                            # Fallback: Replace slot 1 if all slots full
                            self.image_paths[0] = file_path
                            self.update_slot_display(0)
                            self.update_image_info()
                            self.update_status(f"‚úÖ ‡∏ß‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å Clipboard: {Path(file_path).name} ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà slot 1 (slots ‡πÄ‡∏ï‡πá‡∏°)")
                        
                        self.update_ui_state()  # Update button states
                        return
            
            self.update_status("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏†‡∏≤‡∏û‡πÉ‡∏ô Clipboard")
            
        except Exception as e:
            self.update_status(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏á‡∏†‡∏≤‡∏û: {str(e)}")
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event for multiple images"""
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            image_urls = [url for url in urls if self.is_image_file(url.toLocalFile())]
            
            if image_urls:
                count = len(image_urls)
                if count > self.max_images_limit:
                    self.update_status(f"‚ö†Ô∏è ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î {self.max_images_limit} ‡∏†‡∏≤‡∏û (‡∏û‡∏ö {count} ‡∏†‡∏≤‡∏û)")
                else:
                    self.update_status(f"üìÅ ‡∏•‡∏≤‡∏Å‡∏†‡∏≤‡∏û‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà... ({count} ‡∏†‡∏≤‡∏û)")
                event.acceptProposedAction()
                return
        event.ignore()
    
    def dragLeaveEvent(self, event):
        """Handle drag leave event"""
        self.update_mode_indicator()  # Restore mode indicator
    
    def dropEvent(self, event: QDropEvent):
        """üñºÔ∏è Handle drop event for multiple images with slot-based management"""
        try:
            urls = event.mimeData().urls()
            if not urls:
                event.ignore()
                return
            
            # Filter only image files
            image_paths = []
            for url in urls:
                file_path = url.toLocalFile()
                if self.is_image_file(file_path) and self.validate_image_path(file_path):
                    image_paths.append(file_path)
                elif not self.validate_image_path(file_path):
                    print(f"[SECURITY] Dropped file rejected: {file_path}")
            
            if not image_paths:
                self.update_status("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")
                event.ignore()
                return
            
            # üéØ Slot-based Management: Add to next available slots
            added_count = 0
            skipped_files = []
            
            for image_path in image_paths:
                if self.add_image_to_next_available_slot(image_path):
                    added_count += 1
                else:
                    skipped_files.append(Path(image_path).name)
            
            # Save last directory to cache
            if image_paths:
                directory = str(Path(image_paths[0]).parent)
                self.settings.setValue("last_directory", directory)
            
            # Success/Warning messages
            if added_count == 0:
                self.update_status("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ slot ‡∏ß‡πà‡∏≤‡∏á - ‡∏•‡∏ö‡∏†‡∏≤‡∏û‡∏ö‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏Å‡πà‡∏≠‡∏ô")
            elif added_count == len(image_paths):
                if added_count == 1:
                    self.update_status(f"‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏≤‡∏û‡πÉ‡∏ô Slot: {Path(image_paths[0]).name}")
                else:
                    self.update_status(f"‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° {added_count} ‡∏†‡∏≤‡∏û‡πÉ‡∏ô Slots ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
            else:
                self.update_status(f"‚ö†Ô∏è ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ {added_count}/{len(image_paths)} ‡∏†‡∏≤‡∏û - Slots ‡πÄ‡∏ï‡πá‡∏°")
            
            event.acceptProposedAction()
            return
            
        except Exception as e:
            self.update_status(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå: {str(e)}")
        
        event.ignore()
    
    def is_image_file(self, file_path: str) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        if not file_path:
            return False
        
        image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.tiff', '.webp'}
        return Path(file_path).suffix.lower() in image_extensions
    
    def validate_image_path(self, image_path: str) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Ç‡∏≠‡∏á path"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö input ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
            if not image_path or not isinstance(image_path, str):
                return False
            
            # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô absolute path ‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
            path = Path(image_path).resolve()
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
            if not path.exists():
                return False
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà directory)
            if not path.is_file():
                return False
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö extension
            if not self.is_image_file(str(path)):
                return False
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ path traversal patterns ‡πÉ‡∏ô original path
            original_path = str(image_path)
            dangerous_patterns = ['../', '..\\', '~/', '$HOME', '%USERPROFILE%']
            for pattern in dangerous_patterns:
                if pattern in original_path:
                    print(f"[SECURITY] Blocked dangerous path pattern: {pattern}")
                    return False
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå (max 100MB)
            if path.stat().st_size > 100 * 1024 * 1024:
                print(f"[SECURITY] File too large: {path.stat().st_size} bytes")
                return False
            
            return True
            
        except Exception as e:
            print(f"[SECURITY] Path validation failed: {e}")
            return False
    
    @contextmanager
    def _managed_image(self, image_source):
        """Context manager for safe PIL Image handling"""
        image = None
        byte_io = None
        try:
            if isinstance(image_source, bytes):
                # From bytes data
                byte_io = BytesIO(image_source)
                image = Image.open(byte_io)
            elif isinstance(image_source, str):
                # From file path
                image = Image.open(image_source)
            else:
                raise ValueError("Invalid image source type")
            
            # Add to active images list
            self._active_images.append(image)
            yield image
            
        finally:
            # Cleanup
            if image:
                try:
                    image.close()
                except:
                    pass
            if byte_io:
                try:
                    byte_io.close()
                except:
                    pass
            
            # Remove from active images
            if image in self._active_images:
                self._active_images.remove(image)
                
            # Cleanup old images if cache is too large
            self._cleanup_image_cache()
    
    def _cleanup_image_cache(self):
        """Cleanup old cached images"""
        while len(self._active_images) > self._max_cache_size:
            try:
                old_image = self._active_images.pop(0)
                if hasattr(old_image, 'close'):
                    old_image.close()
            except Exception as e:
                print(f"[DEBUG] Error cleaning up image: {e}")
    
    
    def add_resize_handle(self):
        """‡πÄ‡∏û‡∏¥‡πà‡∏° resize grip ‡∏ó‡∏µ‡πà‡∏°‡∏∏‡∏°‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤"""
        self.resize_handle = QLabel()
        self.resize_handle.setFixedSize(15, 15)  # ‡∏•‡∏î‡∏•‡∏á 50% ‡∏à‡∏≤‡∏Å 30x30
        
        # Load resize.png icon
        resize_path = Path("resize.png")
        if resize_path.exists():
            pixmap = QPixmap(str(resize_path))
            if not pixmap.isNull():
                # Scale to fit handle size (50% smaller)
                scaled_pixmap = pixmap.scaled(12, 12, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                self.resize_handle.setPixmap(scaled_pixmap)
            else:
                # Fallback if image fails to load
                self.resize_handle.setText("‚ó¢")
        else:
            # Create resize.png if it doesn't exist
            self.create_resize_icon()
            # Load the created icon
            pixmap = QPixmap(str(resize_path))
            scaled_pixmap = pixmap.scaled(24, 24, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
            self.resize_handle.setPixmap(scaled_pixmap)
        
        self.resize_handle.setStyleSheet("""
            QLabel {
                background: transparent;
                border: none;
                padding: 0px;
                margin: 0px;
            }
            QLabel:hover {
                background: rgba(187, 187, 187, 0.2);
                border-radius: 3px;
            }
        """)
        
        self.resize_handle.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Position resize handle at bottom-right corner (adjusted for new size)
        self.resize_handle.setParent(self)
        self.resize_handle.move(self.width() - 16, self.height() - 16)
        self.resize_handle.raise_()  # Bring to front
        self.resize_handle.show()
        
        # Ensure it stays on top
        self.resize_handle.setAttribute(Qt.WidgetAttribute.WA_AlwaysStackOnTop, True)
    
    def create_resize_icon(self):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô resize.png"""
        # QColor, QPolygon, QPoint already imported
        
        # Create 32x32 pixmap with transparent background
        pixmap = QPixmap(32, 32)
        pixmap.fill(Qt.GlobalColor.transparent)
        
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Set color for resize grip
        painter.setPen(QColor(180, 180, 180))
        painter.setBrush(QColor(140, 140, 140))
        
        # Draw resize grip triangles (bottom-right corner style)
        # Create multiple small triangles to form resize grip pattern
        triangles = [
            # Triangle 1 (bottom-right)
            QPolygon([QPoint(24, 32), QPoint(32, 32), QPoint(32, 24)]),
            # Triangle 2 (middle)
            QPolygon([QPoint(16, 32), QPoint(24, 32), QPoint(24, 24)]),
            QPolygon([QPoint(20, 28), QPoint(28, 28), QPoint(28, 20)]),
            # Triangle 3 (smaller)
            QPolygon([QPoint(12, 32), QPoint(20, 32), QPoint(20, 24)]),
            QPolygon([QPoint(16, 28), QPoint(24, 28), QPoint(24, 20)]),
            QPolygon([QPoint(20, 24), QPoint(28, 24), QPoint(28, 16)])
        ]
        
        for triangle in triangles:
            painter.drawPolygon(triangle)
        
        painter.end()
        
        # Save as resize.png
        pixmap.save("resize.png", "PNG")
        print("Created resize.png icon")
    
    def setup_error_translator(self):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏õ‡∏•‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà error messages"""
        self.error_patterns = {
            # API Authentication Errors
            "PERMISSION_DENIED": {
                "title": "üîê ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏ß‡∏ï‡∏ô",
                "description": "API Key ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á",
                "solutions": [
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö API Key ‡πÉ‡∏ô .env file ‡∏´‡∏£‡∏∑‡∏≠ environment variables",
                    "‡∏•‡∏≠‡∏á refresh API Key ‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å Google AI Studio",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ API Key ‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á Gemini API"
                ]
            },
            
            # Rate Limiting Errors  
            "RESOURCE_EXHAUSTED": {
                "title": "‚è±Ô∏è ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
                "description": "‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ API ‡∏ö‡πà‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡πÄ‡∏Å‡∏¥‡∏ô 2,000 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡∏ô‡∏≤‡∏ó‡∏µ)",
                "solutions": [
                    "‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà",
                    "‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û",
                    "‡πÉ‡∏ä‡πâ‡∏Ñ‡∏¥‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏Ç‡∏≠"
                ]
            },
            
            # Content Policy Errors
            "INVALID_ARGUMENT": {
                "title": "‚ö†Ô∏è ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏Ç‡∏≠",
                "description": "‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÇ‡∏î‡∏¢‡∏ô‡∏µ‡∏ï‡∏†‡∏≤‡∏û",
                "solutions": [
                    "‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á (prompt) ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°",
                    "‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"
                ]
            },
            
            # Server Errors
            "INTERNAL": {
                "title": "üîß ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå Google",
                "description": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á Google",
                "solutions": [
                    "‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£ Google Cloud",
                    "‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏≠‡∏∑‡πà‡∏ô‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß"
                ]
            },
            
            "UNAVAILABLE": {
                "title": "üîß ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
                "description": "‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏°‡∏µ‡∏†‡∏≤‡∏£‡∏∞‡∏á‡∏≤‡∏ô‡∏°‡∏≤‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏¥‡∏î‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á",
                "solutions": [
                    "‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏à‡∏≤‡∏Å Google",
                    "‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô"
                ]
            },
            
            # Common SDK Errors
            "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å API": {
                "title": "üñºÔ∏è ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å API",
                "description": "API ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û ‡∏≠‡∏≤‡∏à‡πÄ‡∏Å‡∏¥‡∏î‡∏à‡∏≤‡∏Å safety filter ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏±‡∏ç‡∏´‡∏≤ parsing",
                "solutions": [
                    "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á (prompt) ‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô",
                    "‡∏£‡∏∞‡∏ö‡∏∏‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û",
                    "‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å",
                    "‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡πÉ‡∏ä‡πâ Legacy SDK"
                ]
            },
            
            "‡πÑ‡∏°‡πà‡∏û‡∏ö candidates ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å API": {
                "title": "üì≠ ‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå",
                "description": "‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å API ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
                "solutions": [
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢",
                    "‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö API key ‡πÅ‡∏•‡∏∞ quota"
                ]
            },
            
            "‡πÑ‡∏°‡πà‡∏û‡∏ö content ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å API": {
                "title": "üìù ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤",
                "description": "API ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤",
                "solutions": [
                    "‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å",
                    "‡∏õ‡∏£‡∏±‡∏ö safety settings"
                ]
            },
            
            "‡πÑ‡∏°‡πà‡∏û‡∏ö parts ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏à‡∏≤‡∏Å API": {
                "title": "üß© ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå",
                "description": "API ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô",
                "solutions": [
                    "‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î",
                    "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô Legacy SDK"
                ]
            },
            
            # Network and Connection Errors
            "Connection": {
                "title": "üåê ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠",
                "description": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ",
                "solutions": [
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï",
                    "‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏≠‡∏µ‡∏Å‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö firewall ‡∏´‡∏£‡∏∑‡∏≠ proxy"
                ]
            },
            
            # Import and Installation Errors
            "ImportError": {
                "title": "üì¶ ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á SDK",
                "description": "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î SDK ‡πÑ‡∏î‡πâ",
                "solutions": [
                    "‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á SDK: pip install google-genai",
                    "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Python version (‡∏ï‡πâ‡∏≠‡∏á 3.9+)",
                    "‡∏•‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÉ‡∏´‡∏°‡πà: pip install --upgrade google-genai"
                ]
            }
        }
    
    def translate_error(self, error_message: str) -> dict:
        """‡πÅ‡∏õ‡∏• error message ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏Ñ‡∏ô‡πÑ‡∏î‡πâ"""
        error_text = str(error_message).lower()
        
        # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ pattern ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô
        for pattern, info in self.error_patterns.items():
            if pattern.lower() in error_text:
                return {
                    "title": info["title"],
                    "description": info["description"],
                    "solutions": info["solutions"],
                    "original": error_message
                }
        
        # Default error ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö error ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å
        return {
            "title": "‚ùì ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏",
            "description": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏∞‡∏ö‡∏∏‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡πÑ‡∏î‡πâ",
            "solutions": [
                "‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
                "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï", 
                "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö API Key",
                "‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡πÉ‡∏ä‡πâ Legacy SDK"
            ],
            "original": error_message
        }
    
    def resizeEvent(self, event):
        """Handle window resize to reposition resize handle"""
        super().resizeEvent(event)
        if hasattr(self, 'resize_handle'):
            self.resize_handle.move(self.width() - 16, self.height() - 16)
            self.resize_handle.raise_()
            self.resize_handle.show()
    
    
    def wheelEvent(self, event):
        """Handle mouse wheel event for font size adjustment"""
        # QWheelEvent, Qt already imported
        
        # Check if Ctrl is pressed
        if event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            # Get the delta (positive = up, negative = down)
            delta = event.angleDelta().y()
            
            if delta > 0:
                # Scroll up = increase font size
                self.current_font_size = min(self.current_font_size + 1, self.max_font_size)
            elif delta < 0:
                # Scroll down = decrease font size
                self.current_font_size = max(self.current_font_size - 1, self.min_font_size)
            
            # Apply new font size to prompt input
            self.apply_font_size()
            
            # Save font size to settings
            self.settings.setValue("font_size", self.current_font_size)
            
            # Update status
            self.update_status(f"Font size: {self.current_font_size}pt")
            
            # Accept the event to prevent default scrolling
            event.accept()
        else:
            # Pass event to parent if Ctrl is not pressed
            super().wheelEvent(event)
    
    def apply_font_size(self):
        """Apply the current font size to the prompt input"""
        if hasattr(self, 'prompt_input'):
            font = self.prompt_input.font()
            font.setPointSize(self.current_font_size)
            self.prompt_input.setFont(font)
    
    def prompt_container_resize_event(self, event):
        """Handle prompt container resize to reposition handle"""
        if hasattr(self, 'prompt_resize_handle'):
            # Position at bottom-right corner (very close to edge)
            self.prompt_resize_handle.move(
                self.prompt_container.width() - self.prompt_resize_handle.width() - 1,
                self.prompt_container.height() - self.prompt_resize_handle.height() - 1
            )
            self.prompt_resize_handle.raise_()
    
    def eventFilter(self, obj, event):
        """Event filter for prompt resize handle"""
        if obj == self.prompt_resize_handle:
            if event.type() == event.Type.MouseButtonPress:
                if event.button() == Qt.MouseButton.LeftButton:
                    self.prompt_resizing = True
                    self.prompt_resize_start_pos = event.globalPosition().toPoint()
                    self.prompt_resize_start_height = self.prompt_container.height()
                    return True
            elif event.type() == event.Type.MouseMove:
                if self.prompt_resizing:
                    delta_y = event.globalPosition().toPoint().y() - self.prompt_resize_start_pos.y()
                    new_height = self.prompt_resize_start_height + delta_y
                    
                    # Limit height between min and max
                    new_height = max(100, min(500, new_height))
                    
                    # Update container heights
                    self.prompt_container.setFixedHeight(new_height)
                    self.prompt_container.setMaximumHeight(new_height)
                    
                    # Update status
                    self.update_status(f"Prompt box height: {new_height}px")
                    
                    return True
            elif event.type() == event.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    self.prompt_resizing = False
                    return True
        
        return super().eventFilter(obj, event)
    
    def is_in_resize_area(self, pos):
        """Check if mouse position is in resize area"""
        margin = 20  # ‡∏•‡∏î‡∏•‡∏á 50% ‡∏à‡∏≤‡∏Å 35 ‡∏ï‡∏≤‡∏° handle ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏°‡πà
        return (pos.x() >= self.width() - margin and pos.y() >= self.height() - margin)
    
    
    def select_image(self):
        """üñºÔ∏è ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö multiple selection ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö slot-based management)"""
        # Get last directory from cache
        last_dir = self.settings.value("last_directory", "")
        
        # Use QFileDialog.getOpenFileNames for multiple selection
        file_paths, _ = QFileDialog.getOpenFileNames(
            self,
            "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Edit (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 4 ‡∏†‡∏≤‡∏û)",
            last_dir,
            "Image Files (*.png *.jpg *.jpeg *.bmp *.gif *.tiff *.webp)"
        )
        
        if not file_paths:
            return
        
        # üéØ Slot-based Management: Add to next available slots
        added_count = 0
        skipped_files = []
        
        for file_path in file_paths:
            if self.validate_image_path(file_path):
                if self.add_image_to_next_available_slot(file_path):
                    added_count += 1
                else:
                    skipped_files.append(Path(file_path).name)
            else:
                print(f"[SECURITY] Selected file rejected: {file_path}")
                skipped_files.append(Path(file_path).name)
        
        if added_count == 0:
            if skipped_files:
                self.update_status("‚ùå ‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ slot ‡∏ß‡πà‡∏≤‡∏á")
            return
        
        # Save directory to cache
        directory = str(Path(file_paths[0]).parent)
        self.settings.setValue("last_directory", directory)
        
        # Success/Warning messages
        if added_count == len(file_paths):
            if added_count == 1:
                self.update_status(f"‚úÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡πÉ‡∏ô Slot: {Path(file_paths[0]).name}")
            else:
                self.update_status(f"‚úÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å {added_count} ‡∏†‡∏≤‡∏û‡πÉ‡∏ô Slots ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
        else:
            self.update_status(f"‚ö†Ô∏è ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ {added_count}/{len(file_paths)} ‡∏†‡∏≤‡∏û - Slots ‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢")
    
    def preload_image(self, image_path: str, clear_existing: bool = False):
        """üñºÔ∏è Preload single image from Promptist - smart slot management
        
        Args:
            image_path: Path to image file
            clear_existing: If True, clear all slots first (default: False)
        """
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Å‡πà‡∏≠‡∏ô
            if not self.validate_image_path(image_path):
                print(f"[SECURITY] Preload blocked - unsafe path: {image_path}")
                self.update_status("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ - ‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢")
                return
                
            if image_path and Path(image_path).exists() and self.is_image_file(image_path):
                # üéØ Clear existing slots if requested (for first-time usage)
                if clear_existing:
                    for i in range(4):
                        self.image_paths[i] = None
                        self.clear_slot_display(i)
                    print(f"[DEBUG] Cleared all existing slots")
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏†‡∏≤‡∏û‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                if image_path in self.image_paths:
                    self.update_status(f"‚ö†Ô∏è ‡∏†‡∏≤‡∏û‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡πÉ‡∏ô slots ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß: {Path(image_path).name}")
                    return
                
                # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô slot ‡∏ß‡πà‡∏≤‡∏á‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                if self.add_image_to_next_available_slot(image_path):
                    action_word = "‡πÇ‡∏´‡∏•‡∏î" if clear_existing else "‡πÄ‡∏û‡∏¥‡πà‡∏°"
                    self.update_status(f"üöÄ {action_word}‡∏†‡∏≤‡∏û: {Path(image_path).name}")
                    print(f"[DEBUG] Successfully added image to next available slot: {Path(image_path).name}")
                else:
                    self.update_status(f"‚ö†Ô∏è Slots ‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏•‡πâ‡∏ß - ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ: {Path(image_path).name}")
                    print(f"[WARNING] All slots full, cannot add image: {Path(image_path).name}")
                    return
                
                # Save directory to cache
                directory = str(Path(image_path).parent)
                self.settings.setValue("last_directory", directory)
                
                self.update_status(f"üöÄ ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û: {Path(image_path).name}")
                print(f"[DEBUG] Successfully preloaded image: {Path(image_path).name}")
            else:
                print(f"[WARNING] Invalid image path: {image_path}")
                self.update_status("‚ö†Ô∏è ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")
        except Exception as e:
            print(f"[ERROR] Failed to preload image: {e}")
            self.update_status(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}")
    
    def create_aspect_ratio_preserved_pixmap(self, image_path: str, max_width: int, max_height: int) -> QPixmap:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á QPixmap ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏Å‡∏©‡∏≤ aspect ratio ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö"""
        try:
            # Load image using managed context to prevent memory leaks
            with self._managed_image(image_path) as img:
                # Convert to Qt format
                if img.mode == 'RGBA':
                    img = img.convert('RGB')
                
                # Convert to bytes using managed BytesIO
                with BytesIO() as byte_array:
                    img.save(byte_array, format='PNG')
                    byte_data = byte_array.getvalue()
                    
                    # Create QPixmap
                    pixmap = QPixmap()
                    pixmap.loadFromData(byte_data)
                    
                    # Scale with aspect ratio preservation
                    if not pixmap.isNull():
                        scaled_pixmap = pixmap.scaled(
                            max_width, max_height,
                            Qt.AspectRatioMode.KeepAspectRatio,
                            Qt.TransformationMode.SmoothTransformation
                        )
                        return scaled_pixmap
                    else:
                        # Return empty pixmap if failed to load
                        return QPixmap()
                    
        except Exception as e:
            print(f"[ERROR] Failed to create pixmap: {e}")
            return QPixmap()
    
    def display_thumbnail(self, image_path: str):
        """‡πÅ‡∏™‡∏î‡∏á thumbnail ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å - ‡∏£‡∏±‡∏Å‡∏©‡∏≤ aspect ratio ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Å‡πà‡∏≠‡∏ô
            if not self.validate_image_path(image_path):
                self.thumbnail_label.setText("‚ùå ‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢")
                print(f"[SECURITY] Display blocked - unsafe path: {image_path}")
                return
                
            # Store the path
            self.selected_image_path = image_path
            
            # ‡πÉ‡∏ä‡πâ helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á pixmap ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏Å‡∏©‡∏≤ aspect ratio
            scaled_pixmap = self.create_aspect_ratio_preserved_pixmap(image_path, 400, 300)
            
            if not scaled_pixmap.isNull():
                # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Label ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏Ç‡∏¢‡∏≤‡∏¢
                self.thumbnail_label.setScaledContents(False)
                self.thumbnail_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                self.thumbnail_label.setPixmap(scaled_pixmap)
            else:
                self.thumbnail_label.setText("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ")
            
            # Show image info using managed context
            file_info = Path(image_path)
            with self._managed_image(image_path) as original_image:
                info_text = (
                    f"üìÅ {file_info.name}\n"
                    f"üìê {original_image.size[0]} √ó {original_image.size[1]}\n"
                    f"üíæ {file_info.stat().st_size / 1024:.1f} KB"
                )
                self.image_info_label.setText(info_text)
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏° click handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö thumbnail image
            self.make_image_clickable(self.thumbnail_label, image_path)
            
        except Exception as e:
            QMessageBox.warning(self, "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ:\n{str(e)}")
    
    def start_editing(self, use_new_sdk: bool = True):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£ edit ‡∏†‡∏≤‡∏û (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö multiple images)"""
        # Check if we have images in session
        if self.get_image_count() == 0:
            QMessageBox.warning(self, "‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£ edit (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö 1-3 ‡∏†‡∏≤‡∏û)")
            return
        
        prompt = self.prompt_input.toPlainText().strip()
        if not prompt:
            QMessageBox.warning(self, "‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏™‡πà prompt", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ edit ‡∏†‡∏≤‡∏û")
            return
        
        # Disable buttons during processing
        self.img_to_img_btn.setEnabled(False)
        if hasattr(self, 'txt_to_img_btn'):
            self.txt_to_img_btn.setEnabled(False)
        if hasattr(self, 'imagen4_btn'):
            self.imagen4_btn.setEnabled(False)
        # [REMOVED] save_btn.setEnabled(False) - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß
        
        # Hide error button and show progress safely
        if hasattr(self, 'error_button'):
            self.error_button.setVisible(False)
        if hasattr(self, 'progress_bar'):
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate progress
            self.progress_bar.setValue(0)  # Reset value
        
        # Show status based on session mode
        mode_text = {
            'single': "üçå ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏µ‡∏¢‡∏ß...",
            'dual': "üçå ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ú‡∏™‡∏°‡∏ú‡∏™‡∏≤‡∏ô 2 ‡∏†‡∏≤‡∏û...", 
            'triple': "üçå ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏•‡∏á‡∏≤‡∏ô‡∏à‡∏≤‡∏Å 3 ‡∏†‡∏≤‡∏û..."
        }
        sdk_name = "New SDK (google-genai)" if use_new_sdk else "Legacy SDK (google-generativeai)"
        self.update_status(f"üçå ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•... ‡∏î‡πâ‡∏ß‡∏¢ {sdk_name}")
        
        # Clear previous results
        self.clear_results()
        
        # Start session-based generation
        self.start_session_generation(use_new_sdk)
    
    def clear_results(self):
        """‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏Å‡πà‡∏≤ - ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà"""
        # ‡∏•‡πâ‡∏≤‡∏á result panel ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏™‡∏π‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        self.result_image_label.clear()
        self.result_image_label.setText("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå")
        self.result_info_label.setText("")
        self.current_results = []
    
    # [FLOATING VIEWER METHODS]
    def open_floating_viewer(self, image_path: str, thumbnail_index: int = None):
        """‡πÄ‡∏õ‡∏¥‡∏î Floating Image Viewer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡πÉ‡∏ô‡∏ä‡∏∏‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        try:
            if not image_path or not os.path.exists(image_path):
                print(f"[FloatingViewer] Image path not found: {image_path}")
                return
                
            # ‡∏õ‡∏¥‡∏î viewer ‡πÄ‡∏î‡∏¥‡∏°‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if self.floating_viewer:
                self.floating_viewer.close()
                self.floating_viewer = None
            
            # ‡∏´‡∏≤‡∏†‡∏≤‡∏û‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ä‡∏∏‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏à‡∏≤‡∏Å temp result files
            current_session_images = []
            clicked_index = 0
            
            # ‡πÉ‡∏ä‡πâ temp_result_files ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
            if hasattr(self, 'temp_result_files') and self.temp_result_files:
                valid_temp_files = [path for path in self.temp_result_files if os.path.exists(path)]
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ error (‡πÑ‡∏°‡πà‡∏°‡∏µ last_result_path ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô None)
                is_error_state = (hasattr(self, 'last_result_path') and self.last_result_path is None)
                
                if valid_temp_files and not is_error_state:
                    current_session_images = valid_temp_files
                    print(f"[FloatingViewer] Found {len(current_session_images)} valid session images")
                    
                    # üîß Fix: Use thumbnail index directly if provided, otherwise fall back to path search
                    if thumbnail_index is not None and 0 <= thumbnail_index < len(current_session_images):
                        clicked_index = thumbnail_index
                        print(f"[FloatingViewer] Using thumbnail index: {clicked_index}")
                    else:
                        # ‡∏´‡∏≤ index ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏¥‡∏Å (fallback method)
                        try:
                            clicked_index = current_session_images.index(image_path)
                            print(f"[FloatingViewer] Clicked image found at index {clicked_index}")
                        except ValueError:
                            clicked_index = 0
                            print(f"[FloatingViewer] Clicked image not in session, using index 0")
                else:
                    print(f"[FloatingViewer] Error state detected or no valid files. Error state: {is_error_state}, Valid files: {len(valid_temp_files) if valid_temp_files else 0}")
            else:
                print("[FloatingViewer] No temp_result_files available")
                    
            # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ session images ‡∏´‡∏£‡∏∑‡∏≠‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏¥‡∏Å‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡∏∏‡∏î ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
            if not current_session_images or image_path not in current_session_images:
                current_session_images = [image_path]
                clicked_index = 0
                print(f"[FloatingViewer] Using single image mode for: {os.path.basename(image_path)}")
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á floating viewer ‡πÉ‡∏´‡∏°‡πà
            self.floating_viewer = FloatingImageViewer(current_session_images, self)
            
            # Set starting index to clicked image
            if clicked_index < len(current_session_images):
                self.floating_viewer.current_index = clicked_index
                self.floating_viewer.image_path = current_session_images[clicked_index]
                if hasattr(self.floating_viewer, 'update_nav_button_states'):
                    self.floating_viewer.update_nav_button_states()
            
            self.floating_viewer.show()
            
            if len(current_session_images) > 1:
                print(f"[FloatingViewer] Opened batch viewer: {clicked_index + 1}/{len(current_session_images)} images")
            else:
                print(f"[FloatingViewer] Opened: {os.path.basename(image_path)}")
            
        except Exception as e:
            print(f"[FloatingViewer] Error opening viewer: {e}")
            QMessageBox.warning(self, "Error", f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ: {str(e)}")
    
    def make_image_clickable(self, label: QLabel, image_path: str):
        """‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏†‡∏≤‡∏û‡∏Ñ‡∏•‡∏¥‡∏Å‡πÑ‡∏î‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î floating viewer"""
        if not label or not image_path:
            return
            
        # ‡πÄ‡∏Å‡πá‡∏ö reference ‡∏Ç‡∏≠‡∏á path
        label.image_path = image_path
        
        # Override mouse events
        def on_mouse_press(event):
            if hasattr(label, 'image_path') and label.image_path:
                # üîß Fix: Pass thumbnail index if available for correct navigation
                thumbnail_index = getattr(label, 'thumbnail_index', None)
                self.open_floating_viewer(label.image_path, thumbnail_index)
        
        def on_enter_event(event):
            label.setCursor(Qt.CursorShape.PointingHandCursor)
            
        def on_leave_event(event):
            label.setCursor(Qt.CursorShape.ArrowCursor)
        
        # Enable mouse tracking and events
        label.setMouseTracking(True)
        label.setAttribute(Qt.WidgetAttribute.WA_Hover, True)
        
        # Set event handlers
        label.mousePressEvent = on_mouse_press
        label.enterEvent = on_enter_event
        label.leaveEvent = on_leave_event
        
        # Set initial cursor
        label.setCursor(Qt.CursorShape.ArrowCursor)
    
    def save_temp_result_image(self, image_data: bytes) -> Optional[str]:
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô temporary file ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö floating viewer"""
        try:
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_file:
                with Image.open(BytesIO(image_data)) as image:
                    if image.mode == 'RGBA':
                        image = image.convert('RGB')
                    image.save(temp_file.name, format='PNG')
                    
                # Track temporary file for cleanup
                self.temp_result_files.append(temp_file.name)
                    
                print(f"[FloatingViewer] Created temp result file: {temp_file.name}")
                return temp_file.name
                
        except Exception as e:
            print(f"[FloatingViewer] Error creating temp result file: {e}")
            return None
    
    # [REMOVED] on_editing_finished() - Merged into on_generation_complete()
    
    def get_next_file_number(self, save_dir: Path, date_str: str) -> int:
        """‡∏´‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÑ‡∏ü‡∏•‡πå‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ"""
        try:
            # ‡∏´‡∏≤ pattern: banana_1sep_*.png
            pattern = f"banana_{date_str}_*.png"
            existing_files = list(save_dir.glob(pattern))
            
            if not existing_files:
                return 1  # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 001
            
            # Extract numbers from existing files
            numbers = []
            for file in existing_files:
                try:
                    # Extract number from banana_1sep_XXX.png
                    name_parts = file.stem.split('_')
                    if len(name_parts) >= 3:
                        number = int(name_parts[2])
                        numbers.append(number)
                except (ValueError, IndexError):
                    continue
            
            # Return next available number
            return max(numbers) + 1 if numbers else 1
            
        except Exception as e:
            print(f"Error getting next file number: {e}")
            return 1

    def _check_saved_files(self) -> List[str]:
        """üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mixed results)"""
        try:
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á date string ‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà: 1sep, 2sep, etc.
            now = datetime.now()
            date_str = f"{now.day}{now.strftime('%b').lower()}"
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏° toggle setting
            if self.save_on_original and self.selected_image_path:
                check_dir = Path(self.selected_image_path).parent
            else:
                check_dir = Path("banana")
            
            if not check_dir.exists():
                return []
            
            # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ pattern banana_<date>_<number>.png
            pattern = f"banana_{date_str}_*.png"
            saved_files = list(check_dir.glob(pattern))
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå (‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô) ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ path string
            saved_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
            
            # ‡πÄ‡∏≠‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ô 5 ‡∏ô‡∏≤‡∏ó‡∏µ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (‡∏Å‡∏£‡∏ì‡∏µ‡∏£‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á)
            current_time = time.time()
            recent_files = []
            for file_path in saved_files[:self.total_workers]:  # ‡πÄ‡∏≠‡∏≤‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô workers
                if current_time - file_path.stat().st_mtime < 300:  # 5 minutes
                    recent_files.append(str(file_path))
            
            return recent_files
            
        except Exception as e:
            print(f"Error checking saved files: {e}")
            return []

    def _display_saved_files_as_results(self, file_paths: List[str]):
        """üì∏ ‡πÅ‡∏™‡∏î‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏õ‡πá‡∏ô results (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mixed results)"""
        try:
            # ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏õ‡πá‡∏ô bytes ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
            results_bytes = []
            for file_path in file_paths:
                with open(file_path, 'rb') as f:
                    image_data = f.read()
                    results_bytes.append(image_data)
            
            if results_bytes:
                # ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô display_results ‡πÄ‡∏î‡∏¥‡∏°
                self.display_results(results_bytes)
                # ‡πÄ‡∏Å‡πá‡∏ö current results ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ click-to-zoom
                self.current_results = results_bytes
            
        except Exception as e:
            print(f"Error displaying saved files: {e}")
            # ‡∏´‡∏≤‡∏Å‡πÅ‡∏™‡∏î‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏ä‡πâ mock thumbnails ‡πÅ‡∏ó‡∏ô
            self.test_display_mock_results()

    def auto_save_results(self, results: List[bytes]):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ï‡∏≤‡∏° toggle setting"""
        try:
            print(f"[AUTO-SAVE] Called with {len(results) if results else 0} results")
            # üõ°Ô∏è ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏õ‡∏•‡πà‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠ invalid results
            if not results:
                print("[AUTO-SAVE] No results to save - skipping auto-save")
                return
                
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ valid image data
            valid_results = []
            for i, image_data in enumerate(results):
                if image_data and len(image_data) > 100:  # ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 100 bytes
                    valid_results.append(image_data)
                else:
                    print(f"[AUTO-SAVE] Skipping invalid image data at index {i}")
                    
            if not valid_results:
                print("[AUTO-SAVE] No valid image data found - skipping auto-save")
                return
                
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á date string ‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà: 1sep, 2sep, etc.
            now = datetime.now()
            date_str = f"{now.day}{now.strftime('%b').lower()}"  # 1sep, 2oct, etc.
            saved_files = []
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ï‡∏≤‡∏° toggle setting
            print(f"[AUTO-SAVE] save_on_original={getattr(self, 'save_on_original', 'NOT_SET')}")
            print(f"[AUTO-SAVE] selected_image_path={getattr(self, 'selected_image_path', 'NOT_SET')}")
            
            if self.save_on_original and self.selected_image_path:
                # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏û‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
                save_dir = Path(self.selected_image_path).parent
                location_text = "‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö"
                print(f"[AUTO-SAVE] Saving to original folder: {save_dir}")
            else:
                # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå banana (default)
                save_dir = Path("banana")
                save_dir.mkdir(exist_ok=True)
                location_text = "‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå banana"
                print(f"[AUTO-SAVE] Saving to banana folder: {save_dir}")
                print(f"[AUTO-SAVE] Directory exists: {save_dir.exists()}")
            
            # ‡∏´‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ
            start_number = self.get_next_file_number(save_dir, date_str)
            
            for i, image_data in enumerate(valid_results):
                # Convert to PIL Image using managed context
                with self._managed_image(image_data) as image:
                    # Generate filename: banana_1sep_001.png
                    filename = f"banana_{date_str}_{start_number + i:03d}.png"
                    filepath = save_dir / filename
                    
                    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥ (safety check)
                    counter = 0
                    original_filepath = filepath
                    while filepath.exists() and counter < 1000:
                        counter += 1
                        filename = f"banana_{date_str}_{start_number + i + counter:03d}.png"
                        filepath = save_dir / filename
                    
                    # Save image
                    image.save(str(filepath), 'PNG')
                    saved_files.append(str(filepath))
            
            self.update_status(f"üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ {len(saved_files)} ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô{location_text}")
            print(f"[AUTO-SAVE] Saved files: {[Path(f).name for f in saved_files]}")
            
            # Auto-refresh notifications removed for standalone version
            
        except Exception as e:
            self.update_status(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÑ‡∏î‡πâ: {str(e)}")
    
    # [REMOVED] on_editing_error() - Merged into on_generation_error()
    
    # notify_promptist_generation_complete removed for standalone version
    
    # ===== MULTIPLE START IMAGES MANAGEMENT =====
    
    def remove_image_from_slot(self, slot_index: int):
        """‡∏•‡∏ö‡∏†‡∏≤‡∏û‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å slot ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î (0-based index)"""
        if 0 <= slot_index < 4:
            self.image_paths[slot_index] = None
            self.update_slot_display(slot_index)
            self.update_image_info()
    
    def add_image_to_next_available_slot(self, image_path: str) -> bool:
        """‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏≤‡∏û‡πÉ‡∏ô slot ‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á‡∏ñ‡∏±‡∏î‡πÑ‡∏õ"""
        for i in range(4):
            if self.image_paths[i] is None:
                self.image_paths[i] = image_path
                self.update_slot_display(i)
                self.update_image_info()
                return True
        return False  # ‡πÑ‡∏°‡πà‡∏°‡∏µ slot ‡∏ß‡πà‡∏≤‡∏á
    
    def update_slot_display(self, slot_index: int):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á slot ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î"""
        if not (0 <= slot_index < 4) or slot_index >= len(self.image_slots):
            return
        
        slot_widget = self.image_slots[slot_index]
        image_label = slot_widget.findChild(QLabel)
        
        if not image_label:
            return
        
        image_path = self.image_paths[slot_index]
        
        if image_path and os.path.exists(image_path):
            # ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û
            try:
                with Image.open(image_path) as img:
                    # Resize ‡πÄ‡∏õ‡πá‡∏ô thumbnail
                    img.thumbnail((120, 120), Image.Resampling.LANCZOS)
                    
                    # Convert ‡πÄ‡∏õ‡πá‡∏ô QPixmap
                    img_bytes = BytesIO()
                    img.save(img_bytes, format='PNG')
                    img_bytes.seek(0)
                    
                    qimg = QPixmap()
                    qimg.loadFromData(img_bytes.getvalue())
                    
                    image_label.setPixmap(qimg)
                    image_label.setText("")  # ‡∏•‡∏ö text
                    
                    # ‡πÅ‡∏™‡∏î‡∏á delete button
                    if hasattr(image_label, 'delete_button'):
                        image_label.delete_button.setVisible(True)
                        # Update button position - use fixed position
                        image_label.delete_button.move(95, 5)  # Fixed position for 120px slot
                        image_label.delete_button.raise_()  # Bring to front
                    
                    # ‡∏ó‡∏≥‡πÉ‡∏´‡πâ clickable
                    self.make_image_clickable(image_label, image_path)
            
            except Exception as e:
                print(f"Error loading image for slot {slot_index}: {e}")
                self.clear_slot_display(slot_index)
        else:
            # Clear slot
            self.clear_slot_display(slot_index)
    
    def clear_slot_display(self, slot_index: int):
        """‡∏•‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Ç‡∏≠‡∏á slot ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î"""
        if not (0 <= slot_index < 4) or slot_index >= len(self.image_slots):
            return
        
        slot_widget = self.image_slots[slot_index]
        image_label = slot_widget.findChild(QLabel)
        
        if not image_label:
            return
        
        image_label.clear()
        image_label.setText(f"Slot {slot_index + 1}")
        
        # ‡∏ã‡πà‡∏≠‡∏ô delete button
        if hasattr(image_label, 'delete_button'):
            image_label.delete_button.setVisible(False)
    
    def get_active_image_paths(self) -> List[str]:
        """‡πÑ‡∏î‡πâ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ path ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô slots (‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏° None)"""
        return [path for path in self.image_paths if path is not None]
    
    def get_image_count(self) -> int:
        """‡πÑ‡∏î‡πâ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô slots"""
        return len(self.get_active_image_paths())
    
    def update_image_info(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï image info label ‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
        active_images = self.get_active_image_paths()
        count = len(active_images)
        
        if count == 0:
            self.image_info_label.setText("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏û")
            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï legacy selected_image_path
            self.selected_image_path = None
        else:
            info_text = f"{count} ‡∏†‡∏≤‡∏û‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å"
            if count == 1:
                # ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
                try:
                    img_path = active_images[0]
                    with Image.open(img_path) as img:
                        size_mb = os.path.getsize(img_path) / (1024 * 1024)
                        info_text = f"1 ‡∏†‡∏≤‡∏û: {img.width}√ó{img.height}\n{size_mb:.1f} MB"
                except:
                    pass
            
            self.image_info_label.setText(info_text)
            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï legacy selected_image_path ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡πÅ‡∏£‡∏Å
            self.selected_image_path = active_images[0]
    
    def show_error_detail(self):
        """‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î error ‡πÅ‡∏ö‡∏ö‡πÄ‡∏ï‡πá‡∏°"""
        if hasattr(self, 'last_translated_error') and self.last_translated_error:
            self.show_enhanced_error_dialog(self.last_translated_error)
        elif self.last_error_message:
            self.show_error_dialog("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ edit ‡∏†‡∏≤‡∏û", self.last_error_message)
    
    def show_error_image(self):
        """‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û error ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à"""
        try:
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û error ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏á‡πà‡∏≤‡∏¢
            error_pixmap = QPixmap(200, 200)
            error_pixmap.fill(QColor(48, 69, 48))  # ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡πÄ‡∏Ç‡πâ‡∏°
            
            # ‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error
            from PySide6.QtGui import QPainter, QFont, QPen
            painter = QPainter(error_pixmap)
            painter.setPen(QPen(QColor(200, 230, 201), 2))  # ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏≠‡πà‡∏≠‡∏ô
            
            # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ü‡∏≠‡∏ô‡∏ï‡πå
            font = QFont("Arial", 14, QFont.Weight.Bold)
            painter.setFont(font)
            
            # ‡∏ß‡∏≤‡∏î‡πÑ‡∏≠‡∏Ñ‡∏≠‡∏ô X
            painter.drawLine(50, 50, 150, 150)
            painter.drawLine(150, 50, 50, 150)
            
            # ‡∏ß‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
            painter.drawText(error_pixmap.rect(), Qt.AlignmentFlag.AlignCenter, "‚ùå\nGeneration\nFailed")
            painter.end()
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û error ‡πÉ‡∏ô result label
            scaled_pixmap = error_pixmap.scaled(
                self.result_image_label.width(), 
                self.result_image_label.height(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            self.result_image_label.setPixmap(scaled_pixmap)
            
            print("[ERROR-IMAGE] Displayed error image in result panel")
            
        except Exception as e:
            print(f"[ERROR] Failed to create error image: {e}")
            # Fallback to text message
            self.result_image_label.setText("‚ùå ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡πÉ‡∏´‡∏°‡πà")
    
    def show_error_dialog(self, title: str, error_message: str):
        """‡πÅ‡∏™‡∏î‡∏á error dialog ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏î‡πâ"""
        # QDialog, QTextEdit, QPushButton already imported
        
        dialog = QDialog(self)
        dialog.setWindowTitle(title)
        dialog.setModal(True)
        
        # Make dialog resizable and larger
        dialog.resize(800, 600)
        dialog.setMinimumSize(600, 400)
        
        # Set dark theme for dialog
        dialog.setStyleSheet("""
            QDialog {
                background-color: #1f2e1f;
                color: #c8e6c9;
                border: 1px solid #304530;
            }
            QTextEdit {
                background-color: #1a281a;
                border: 1px solid #405040;
                color: #c8e6c9;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 12px;
                padding: 10px;
            }
            QPushButton {
                padding: 10px 20px;
                font-size: 13px;
                font-weight: 600;
                background-color: #304530;
                color: #c8e6c9;
                border: 1px solid #405040;
            }
            QPushButton:hover {
                background-color: #3a5a3a;
                border: 1px solid #608060;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Title label
        title_label = QLabel(f"‚ùå {title}")
        title_label.setStyleSheet("""
            QLabel {
                font-size: 16px;
                font-weight: bold;
                color: #ff6b6b;
                padding: 10px 0;
            }
        """)
        layout.addWidget(title_label)
        
        # Error text (scrollable and selectable)
        error_text = QTextEdit()
        error_text.setPlainText(error_message)
        error_text.setReadOnly(True)
        layout.addWidget(error_text)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        copy_btn = QPushButton("üìã ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å Error")
        # QGuiApplication already imported
        copy_btn.clicked.connect(lambda: QGuiApplication.clipboard().setText(error_message))
        button_layout.addWidget(copy_btn)
        
        button_layout.addStretch()
        
        close_btn = QPushButton("‡∏õ‡∏¥‡∏î")
        close_btn.clicked.connect(dialog.close)
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
        
        # Show dialog
        dialog.exec()
    
    def show_enhanced_error_dialog(self, translated_error: dict):
        """‡πÅ‡∏™‡∏î‡∏á enhanced error dialog ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ñ‡∏≥‡πÅ‡∏õ‡∏•‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥"""
        # QDialog, QTextEdit, QPushButton already imported, QListWidget, QListWidgetItem
        
        dialog = QDialog(self)
        dialog.setWindowTitle(translated_error["title"])
        dialog.setModal(True)
        
        # Make dialog larger for better UX
        dialog.resize(900, 700)
        dialog.setMinimumSize(700, 500)
        
        # Set dark theme for dialog
        dialog.setStyleSheet("""
            QDialog {
                background-color: #1f2e1f;
                color: #c8e6c9;
                border: 1px solid #304530;
            }
            QTextEdit {
                background-color: #1a281a;
                border: 1px solid #405040;
                color: #c8e6c9;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 12px;
                padding: 10px;
            }
            QPushButton {
                padding: 10px 20px;
                font-size: 13px;
                font-weight: 600;
                background-color: #304530;
                color: #c8e6c9;
                border: 1px solid #405040;
            }
            QPushButton:hover {
                background-color: #3a5a3a;
                border: 1px solid #608060;
            }
            QListWidget {
                background-color: #1a281a;
                border: 1px solid #405040;
                color: #c8e6c9;
                font-size: 13px;
                padding: 5px;
            }
            QListWidget::item {
                padding: 8px;
                border-bottom: 1px solid #243324;
            }
            QListWidget::item:hover {
                background-color: #243324;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Title and description
        title_label = QLabel(translated_error["title"])
        title_label.setStyleSheet("""
            QLabel {
                font-size: 18px;
                font-weight: bold;
                color: #ff6b6b;
                padding: 15px 0;
            }
        """)
        layout.addWidget(title_label)
        
        desc_label = QLabel(translated_error["description"])
        desc_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                color: #c8e6c9;
                padding: 10px;
                background-color: #263a26;
                border-left: 4px solid #ff6b6b;
                margin-bottom: 15px;
            }
        """)
        desc_label.setWordWrap(True)
        layout.addWidget(desc_label)
        
        # Solutions section
        solutions_label = QLabel("üí° ‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:")
        solutions_label.setStyleSheet("""
            QLabel {
                font-size: 16px;
                font-weight: bold;
                color: #4CAF50;
                padding: 10px 0;
            }
        """)
        layout.addWidget(solutions_label)
        
        # Solutions list
        solutions_list = QListWidget()
        for i, solution in enumerate(translated_error["solutions"], 1):
            item = QListWidgetItem(f"{i}. {solution}")
            solutions_list.addItem(item)
        layout.addWidget(solutions_list)
        
        # Original error (collapsible)
        original_label = QLabel("üîç ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏Å‡∏û‡∏±‡∏í‡∏ô‡∏≤):")
        original_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                font-weight: bold;
                color: #889888;
                padding: 10px 0 5px 0;
            }
        """)
        layout.addWidget(original_label)
        
        # Original error text (scrollable and selectable)
        error_text = QTextEdit()
        error_text.setPlainText(translated_error["original"])
        error_text.setReadOnly(True)
        error_text.setMaximumHeight(150)  # Limit height
        layout.addWidget(error_text)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        copy_btn = QPushButton("üìã ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å Error ‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ")
        # QGuiApplication already imported
        copy_btn.clicked.connect(lambda: QGuiApplication.clipboard().setText(translated_error["original"]))
        button_layout.addWidget(copy_btn)
        
        copy_solutions_btn = QPushButton("üìù ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç")
        solutions_text = f"{translated_error['title']}\n\n{translated_error['description']}\n\n‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç:\n" + \
                        "\n".join([f"{i}. {sol}" for i, sol in enumerate(translated_error['solutions'], 1)])
        copy_solutions_btn.clicked.connect(lambda: QGuiApplication.clipboard().setText(solutions_text))
        button_layout.addWidget(copy_solutions_btn)
        
        button_layout.addStretch()
        
        close_btn = QPushButton("‡∏õ‡∏¥‡∏î")
        close_btn.clicked.connect(dialog.close)
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
        
        # Show dialog
        dialog.exec()
    
    def display_results(self, results: List[bytes]):
        """‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå - single image ‡∏´‡∏£‡∏∑‡∏≠ grid layout ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö multiple images"""
        print(f"[DISPLAY-RESULTS] Called with {len(results) if results else 0} results")
        if not results:
            print("[DISPLAY-RESULTS] No results to display, returning early")
            return
            
        try:
            # ‡∏ã‡πà‡∏≠‡∏ô error state ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
            if hasattr(self, 'result_image_label'):
                # Clear error image/text ‡πÅ‡∏•‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô normal state
                self.result_image_label.setText("")
                print("[DISPLAY-RESULTS] Cleared error state")
            
            # Store results 
            self.current_results = results
            print(f"[DISPLAY-RESULTS] Stored {len(results)} results")
            
            if len(results) == 1:
                # Single image - ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°
                print("[DISPLAY-RESULTS] Displaying single result")
                self._display_single_result(results[0])
            else:
                # Multiple images - ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ö‡∏ö grid 2x2
                print(f"[DISPLAY-RESULTS] Displaying {len(results)} results in grid")
                self._display_grid_results(results)
                
        except Exception as e:
            print(f"[DISPLAY-RESULTS] Error in display_results: {str(e)}")
            import traceback
            traceback.print_exc()
            self.update_status(f"‚ùå Error displaying results: {str(e)}")
    
    def _display_grid_results(self, results: List[bytes]):
        """‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏û‡πÅ‡∏ö‡∏ö‡πÅ‡∏¢‡∏Å thumbnails 2x2 (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ù‡∏±‡πà‡∏á‡∏ã‡πâ‡∏≤‡∏¢)"""
        try:
            # ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå result_image_label ‡πÄ‡∏Å‡πà‡∏≤ ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á grid layout
            self.result_image_label.clear()
            self.result_image_label.setText("")
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á container widget ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö grid
            if not hasattr(self, 'result_grid_container'):
                self.result_grid_container = QWidget()
                self.result_grid_layout = QGridLayout(self.result_grid_container)
                self.result_grid_layout.setSpacing(10)  # ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á 10px
                self.result_grid_layout.setContentsMargins(5, 5, 5, 5)
                
                # ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà result_image_label ‡∏î‡πâ‡∏ß‡∏¢ grid container
                parent_layout = self.result_image_label.parent().layout()
                label_index = -1
                for i in range(parent_layout.count()):
                    if parent_layout.itemAt(i).widget() == self.result_image_label:
                        label_index = i
                        break
                
                if label_index >= 0:
                    parent_layout.removeWidget(self.result_image_label)
                    self.result_image_label.hide()
                    parent_layout.insertWidget(label_index, self.result_grid_container)
            
            # ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå thumbnails ‡πÄ‡∏Å‡πà‡∏≤
            for i in reversed(range(self.result_grid_layout.count())):
                child = self.result_grid_layout.itemAt(i).widget()
                if child:
                    child.deleteLater()
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á thumbnail ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏†‡∏≤‡∏û
            self.result_thumbnails = []
            for i, image_data in enumerate(results[:4]):  # ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 4 ‡∏†‡∏≤‡∏û
                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏ô grid 2x2
                row = i // 2
                col = i % 2
                
                # ‡∏™‡∏£‡πâ‡∏≤‡∏á thumbnail label
                thumbnail = QLabel()
                thumbnail.setFixedSize(120, 120)  # ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ñ‡∏á‡∏ó‡∏µ‡πà
                thumbnail.setStyleSheet("""
                    QLabel {
                        border: 2px solid #405040;
                        border-radius: 8px;
                        background-color: #1f2e1f;
                        padding: 3px;
                    }
                    QLabel:hover {
                        border-color: #608060;
                        background-color: #2a3d2a;
                    }
                """)
                thumbnail.setAlignment(Qt.AlignmentFlag.AlignCenter)
                thumbnail.setScaledContents(False)
                
                # ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û
                with self._managed_image(image_data) as img:
                    if img.mode == 'RGBA':
                        img = img.convert('RGB')
                    
                    # ‡∏™‡∏£‡πâ‡∏≤‡∏á QPixmap
                    with BytesIO() as byte_array:
                        img.save(byte_array, format='PNG')
                        byte_data = byte_array.getvalue()
                        
                        pixmap = QPixmap()
                        pixmap.loadFromData(byte_data)
                        
                        # Scale ‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏Å‡∏±‡∏ö thumbnail
                        scaled_pixmap = pixmap.scaled(
                            114, 114,  # 120-6 padding
                            Qt.AspectRatioMode.KeepAspectRatio,
                            Qt.TransformationMode.SmoothTransformation
                        )
                        
                        thumbnail.setPixmap(scaled_pixmap)
                
                # ‡πÄ‡∏û‡∏¥‡πà‡∏° click handler ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏Å‡πá‡∏ö index
                temp_result_path = self.save_temp_result_image(image_data)
                if temp_result_path:
                    # üîß Fix: Store thumbnail index for correct floating viewer navigation
                    thumbnail.thumbnail_index = i
                    thumbnail.image_path = temp_result_path
                    self.make_image_clickable(thumbnail, temp_result_path)
                
                # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô grid
                self.result_grid_layout.addWidget(thumbnail, row, col)
                self.result_thumbnails.append(thumbnail)
            
            # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï info label ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö multiple images
            total_size = sum(len(data) for data in results)
            if total_size < 1024 * 1024:
                size_str = f"{total_size / 1024:.1f} KB"
            else:
                size_str = f"{total_size / (1024 * 1024):.1f} MB"
            
            info_text = f"üìÅ {len(results)} images\nüìê Multiple thumbnails\nüíæ {size_str}"
            self.result_info_label.setText(info_text)
                
        except Exception as e:
            print(f"Error in _display_grid_results: {str(e)}")
            self.update_status(f"‚ùå Error displaying grid: {str(e)}")
    
    def _display_single_result(self, image_data: bytes):
        """‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°"""
        print(f"[SINGLE-RESULT] Called with {len(image_data)} bytes")
        try:
            # ‡∏ã‡πà‡∏≠‡∏ô grid container (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á single image label
            if hasattr(self, 'result_grid_container'):
                print("[SINGLE-RESULT] Hiding grid container and showing single label")
                self.result_grid_container.hide()
                self.result_image_label.show()
                
                # ‡πÉ‡∏™‡πà result_image_label ‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô layout ‡∏´‡∏≤‡∏Å‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ
                parent_layout = self.result_grid_container.parent().layout()
                if parent_layout and not any(parent_layout.itemAt(i).widget() == self.result_image_label 
                                           for i in range(parent_layout.count())):
                    grid_index = -1
                    for i in range(parent_layout.count()):
                        if parent_layout.itemAt(i).widget() == self.result_grid_container:
                            grid_index = i
                            break
                    
                    if grid_index >= 0:
                        parent_layout.insertWidget(grid_index, self.result_image_label)
            
            with self._managed_image(image_data) as image:
                # Convert to Qt format
                if image.mode == 'RGBA':
                    image = image.convert('RGB')
                
                # Create BytesIO in context to ensure cleanup
                with BytesIO() as byte_array:
                    image.save(byte_array, format='PNG')
                    byte_data = byte_array.getvalue()
                    
                    pixmap = QPixmap()
                    pixmap.loadFromData(byte_data)
                    
                    # ‡∏ü‡∏¥‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà result_image_label ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô thumbnail (fixed size)
                    label_size = self.result_image_label.size()
                    available_width = label_size.width() - 14  # 5px padding x2 + 2px border x2
                    available_height = label_size.height() - 14
                    
                    scaled_pixmap = pixmap.scaled(
                        available_width, available_height,
                        Qt.AspectRatioMode.KeepAspectRatio, 
                        Qt.TransformationMode.SmoothTransformation
                    )
                    
                    print(f"[SINGLE-RESULT] Setting pixmap: {scaled_pixmap.size().width()}x{scaled_pixmap.size().height()}")
                    self.result_image_label.setPixmap(scaled_pixmap)
                    print("[SINGLE-RESULT] Pixmap set successfully")
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á info label
            filename = f"banana_result_001.png"  # ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
            size_text = f"{image.size[0]} √ó {image.size[1]}"
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå (approximate)
            file_size_bytes = len(image_data)
            if file_size_bytes < 1024:
                size_str = f"{file_size_bytes} B"
            elif file_size_bytes < 1024 * 1024:
                size_str = f"{file_size_bytes / 1024:.1f} KB"
            else:
                size_str = f"{file_size_bytes / (1024 * 1024):.1f} MB"
                
            info_text = f"üìÅ {filename}\nüìê {size_text}\nüíæ {size_str}"
            self.result_info_label.setText(info_text)
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á temporary file ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö floating viewer
            temp_result_path = self.save_temp_result_image(image_data)
            if temp_result_path:
                self.make_image_clickable(self.result_image_label, temp_result_path)
                
        except Exception as e:
            print(f"Error in _display_single_result: {str(e)}")
    
    def save_results(self):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÅ‡∏ö‡∏ö manual (‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå)"""
        if not self.current_results:
            QMessageBox.information(self, "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå", "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏´‡πâ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å")
            return
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á error image
        if hasattr(self, 'last_result_path') and self.last_result_path is None:
            QMessageBox.warning(self, "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏î‡πâ", "‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å")
            return
        
        # ‡πÄ‡∏™‡∏ô‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ï‡∏≤‡∏° toggle setting
        if self.save_on_original and self.selected_image_path:
            initial_dir = str(Path(self.selected_image_path).parent)
        else:
            initial_dir = str(Path("banana").resolve())
        
        # Choose save directory
        save_dir = QFileDialog.getExistingDirectory(
            self, 
            "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å",
            initial_dir
        )
        if not save_dir:
            return
        
        try:
            # Use new naming system
            now = datetime.now()
            date_str = f"{now.day}{now.strftime('%b').lower()}"
            save_path = Path(save_dir)
            start_number = self.get_next_file_number(save_path, date_str)
            saved_files = []
            
            for i, image_data in enumerate(self.current_results):
                # Convert to PIL Image
                image = Image.open(BytesIO(image_data))
                
                # Generate filename using new system
                filename = f"banana_{date_str}_{start_number + i:03d}.png"
                filepath = save_path / filename
                
                # Safety check for file collision
                counter = 0
                while filepath.exists() and counter < 1000:
                    counter += 1
                    filename = f"banana_{date_str}_{start_number + i + counter:03d}.png"
                    filepath = save_path / filename
                
                # Save image
                image.save(str(filepath), 'PNG')
                saved_files.append(str(filepath))
            
            self.update_status(f"üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß {len(saved_files)} ‡πÑ‡∏ü‡∏•‡πå")
            
            QMessageBox.information(
                self, 
                "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô",
                f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå {len(saved_files)} ‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡πâ‡∏ß:\n\n" + 
                "\n".join([Path(f).name for f in saved_files])
            )
            
        except Exception as e:
            QMessageBox.critical(self, "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ:\n{str(e)}")
    
    # === Multiple Start Images Session Management ===
    
    def clear_image_session(self, keep_prompt=True):
        """‡∏•‡πâ‡∏≤‡∏á session ‡∏†‡∏≤‡∏û ‡πÅ‡∏ï‡πà‡πÄ‡∏Å‡πá‡∏ö prompt ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏∑‡πà‡∏ô"""
        # Clear existing thumbnails
        for thumbnail in self.image_session['thumbnails']:
            if thumbnail and hasattr(thumbnail, 'deleteLater'):
                thumbnail.deleteLater()
        
        # Reset session data
        self.image_session = {
            'paths': [],
            'thumbnails': [], 
            'count': 0,
            'mode': 'single'
        }
        
        # Reset legacy selected_image_path for backward compatibility
        self.selected_image_path = None
        
        # Update UI
        self.update_responsive_ui()
        
        status_msg = "üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏° session ‡πÉ‡∏´‡∏°‡πà"
        if keep_prompt:
            status_msg += " (‡πÄ‡∏Å‡πá‡∏ö prompt ‡πÑ‡∏ß‡πâ)"
        self.update_status(status_msg)
    
    def update_responsive_ui(self):
        """üñºÔ∏è ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö slot-based system - simplified"""
        # ‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ slots ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß
        self.update_ui_state()  # Update button states only
    
    def hide_all_previews(self):
        """‡∏ã‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
        # ‡∏•‡∏ö multi_image_container ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
        if hasattr(self, 'multi_image_container') and self.multi_image_container:
            self.multi_image_container.deleteLater()
            self.multi_image_container = None
        
        # ‡πÅ‡∏™‡∏î‡∏á thumbnail_label ‡∏Å‡∏•‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï
        if hasattr(self, 'thumbnail_label'):
            self.thumbnail_label.show()
            self.thumbnail_label.clear()
            self.thumbnail_label.setText("‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà\n‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å\n(‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö 1-3 ‡∏†‡∏≤‡∏û)")
            self.thumbnail_label.setStyleSheet("""
                QLabel {
                    border: 2px dashed #608060;
                    border-radius: 10px;
                    background-color: #263a26;
                    color: #c8e6c9;
                    font-size: 14px;
                    text-align: center;
                    padding: 20px;
                }
                QLabel:hover {
                    background-color: #304530;
                    border-color: #80b080;
                }
            """)
    
    def show_single_image_layout(self):
        """‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°"""
        # ‡∏•‡∏ö multi_image_container ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
        if hasattr(self, 'multi_image_container') and self.multi_image_container:
            self.multi_image_container.deleteLater()
            self.multi_image_container = None
        
        # ‡πÅ‡∏™‡∏î‡∏á thumbnail_label ‡∏Å‡∏•‡∏±‡∏ö
        self.thumbnail_label.show()
        
        if self.get_image_count() >= 1:
            active_paths = self.get_active_image_paths()
            image_path = active_paths[0] if active_paths else None
            self.display_thumbnail(image_path)
            # Update legacy path for compatibility
            self.selected_image_path = image_path
    
    def show_dual_images_layout(self):
        """‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏≠‡∏á‡∏†‡∏≤‡∏û‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô"""
        if self.get_image_count() >= 2:
            # ‡∏ã‡πà‡∏≠‡∏ô thumbnail_label ‡πÄ‡∏î‡∏¥‡∏°
            self.thumbnail_label.hide()
            
            # ‡∏•‡∏ö layout ‡πÄ‡∏Å‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if hasattr(self, 'multi_image_container') and self.multi_image_container:
                self.multi_image_container.deleteLater()
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á container ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ
            self.multi_image_container = QFrame()
            self.multi_image_container.setStyleSheet("""
                QFrame {
                    border: 2px dashed #405040;
                    background-color: #1a281a;
                    border-radius: 10px;
                    min-height: 400px;
                }
            """)
            
            # Layout ‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 2 ‡∏†‡∏≤‡∏û
            h_layout = QHBoxLayout(self.multi_image_container)
            h_layout.setSpacing(10)
            h_layout.setContentsMargins(10, 10, 10, 10)
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏±‡πâ‡∏á 2
            for i in range(2):
                active_paths = self.get_active_image_paths()
                image_path = active_paths[i] if i < len(active_paths) else None
                
                # Container ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏π‡∏õ
                img_container = QFrame()
                img_container.setStyleSheet("""
                    QFrame {
                        border: 1px solid #608060;
                        border-radius: 5px;
                        background-color: #253525;
                    }
                """)
                
                img_layout = QVBoxLayout(img_container)
                img_layout.setSpacing(5)
                img_layout.setContentsMargins(5, 5, 5, 5)
                
                # Label ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç
                number_label = QLabel(f"({i+1}/2)")
                number_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                number_label.setStyleSheet("""
                    QLabel {
                        color: #c8e6c9;
                        font-size: 11px;
                        font-weight: bold;
                        background-color: transparent;
                        border: none;
                        padding: 2px;
                    }
                """)
                img_layout.addWidget(number_label)
                
                # Label ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û
                img_label = QLabel()
                img_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                img_label.setScaledContents(False)
                img_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
                img_label.setStyleSheet("""
                    QLabel {
                        border: 1px solid #405040;
                        background-color: #1a281a;
                        min-height: 180px;
                        min-width: 200px;
                    }
                """)
                
                # ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û
                try:
                    # ‡πÉ‡∏ä‡πâ helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á pixmap ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏Å‡∏©‡∏≤ aspect ratio
                    scaled_pixmap = self.create_aspect_ratio_preserved_pixmap(image_path, 260, 200)
                    
                    if not scaled_pixmap.isNull():
                        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Label ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
                        img_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                        img_label.setScaledContents(False)
                        img_label.setPixmap(scaled_pixmap)
                        
                        # ‡πÄ‡∏û‡∏¥‡πà‡∏° click handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÉ‡∏ô session
                        self.make_image_clickable(img_label, image_path)
                    else:
                        img_label.setText(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û {i+1}")
                        
                except Exception as e:
                    img_label.setText(f"Error loading image {i+1}")
                    print(f"[ERROR] Failed to load image {i+1}: {e}")
                
                img_layout.addWidget(img_label, 1)
                
                # ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå
                file_label = QLabel(Path(image_path).name)
                file_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                file_label.setStyleSheet("""
                    QLabel {
                        color: #9a9a9a;
                        font-size: 9px;
                        background-color: transparent;
                        border: none;
                        padding: 2px;
                    }
                """)
                file_label.setWordWrap(True)
                img_layout.addWidget(file_label)
                
                h_layout.addWidget(img_container)
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏° container ‡πÄ‡∏Ç‡πâ‡∏≤ layout ‡∏Ç‡∏≠‡∏á left panel
            left_panel_layout = self.thumbnail_label.parent().layout()
            if left_panel_layout:
                # ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á thumbnail_label ‡πÄ‡∏î‡∏¥‡∏°
                index = -1
                for i in range(left_panel_layout.count()):
                    if left_panel_layout.itemAt(i) and left_panel_layout.itemAt(i).widget() == self.thumbnail_label:
                        index = i
                        break
                
                if index >= 0:
                    left_panel_layout.insertWidget(index, self.multi_image_container, 1)
            
            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï selected_image_path ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡πÅ‡∏£‡∏Å
            active_paths = self.get_active_image_paths()
            self.selected_image_path = active_paths[0] if active_paths else None
    
    def show_triple_images_layout(self):
        """‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏≤‡∏°‡∏†‡∏≤‡∏û‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô"""
        if self.get_image_count() >= 3:
            # ‡∏ã‡πà‡∏≠‡∏ô thumbnail_label ‡πÄ‡∏î‡∏¥‡∏°
            self.thumbnail_label.hide()
            
            # ‡∏•‡∏ö layout ‡πÄ‡∏Å‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if hasattr(self, 'multi_image_container') and self.multi_image_container:
                self.multi_image_container.deleteLater()
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á container ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ
            self.multi_image_container = QFrame()
            self.multi_image_container.setStyleSheet("""
                QFrame {
                    border: 2px dashed #405040;
                    background-color: #1a281a;
                    border-radius: 10px;
                    min-height: 400px;
                }
            """)
            
            # Layout ‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 3 ‡∏†‡∏≤‡∏û
            h_layout = QHBoxLayout(self.multi_image_container)
            h_layout.setSpacing(8)
            h_layout.setContentsMargins(8, 10, 8, 10)
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏±‡πâ‡∏á 3
            for i in range(3):
                active_paths = self.get_active_image_paths()
                image_path = active_paths[i] if i < len(active_paths) else None
                
                # Container ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏π‡∏õ
                img_container = QFrame()
                img_container.setStyleSheet("""
                    QFrame {
                        border: 1px solid #608060;
                        border-radius: 5px;
                        background-color: #253525;
                    }
                """)
                
                img_layout = QVBoxLayout(img_container)
                img_layout.setSpacing(3)
                img_layout.setContentsMargins(3, 3, 3, 3)
                
                # Label ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç
                number_label = QLabel(f"({i+1}/3)")
                number_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                number_label.setStyleSheet("""
                    QLabel {
                        color: #c8e6c9;
                        font-size: 10px;
                        font-weight: bold;
                        background-color: transparent;
                        border: none;
                        padding: 2px;
                    }
                """)
                img_layout.addWidget(number_label)
                
                # Label ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û
                img_label = QLabel()
                img_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                img_label.setScaledContents(False)
                img_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
                img_label.setStyleSheet("""
                    QLabel {
                        border: 1px solid #405040;
                        background-color: #1a281a;
                        min-height: 140px;
                        min-width: 150px;
                    }
                """)
                
                # ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û
                try:
                    # ‡πÉ‡∏ä‡πâ helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á pixmap ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏Å‡∏©‡∏≤ aspect ratio
                    scaled_pixmap = self.create_aspect_ratio_preserved_pixmap(image_path, 170, 140)
                    
                    if not scaled_pixmap.isNull():
                        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Label ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
                        img_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                        img_label.setScaledContents(False)
                        img_label.setPixmap(scaled_pixmap)
                        
                        # ‡πÄ‡∏û‡∏¥‡πà‡∏° click handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÉ‡∏ô session
                        self.make_image_clickable(img_label, image_path)
                    else:
                        img_label.setText(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û {i+1}")
                        
                except Exception as e:
                    img_label.setText(f"Error loading image {i+1}")
                    print(f"[ERROR] Failed to load image {i+1}: {e}")
                
                img_layout.addWidget(img_label, 1)
                
                # ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå
                file_label = QLabel(Path(image_path).name)
                file_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                file_label.setStyleSheet("""
                    QLabel {
                        color: #9a9a9a;
                        font-size: 8px;
                        background-color: transparent;
                        border: none;
                        padding: 1px;
                    }
                """)
                file_label.setWordWrap(True)
                img_layout.addWidget(file_label)
                
                h_layout.addWidget(img_container)
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏° container ‡πÄ‡∏Ç‡πâ‡∏≤ layout ‡∏Ç‡∏≠‡∏á left panel
            left_panel_layout = self.thumbnail_label.parent().layout()
            if left_panel_layout:
                # ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á thumbnail_label ‡πÄ‡∏î‡∏¥‡∏°
                index = -1
                for i in range(left_panel_layout.count()):
                    if left_panel_layout.itemAt(i) and left_panel_layout.itemAt(i).widget() == self.thumbnail_label:
                        index = i
                        break
                
                if index >= 0:
                    left_panel_layout.insertWidget(index, self.multi_image_container, 1)
            
            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï selected_image_path ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡πÅ‡∏£‡∏Å
            active_paths = self.get_active_image_paths()
            self.selected_image_path = active_paths[0] if active_paths else None
    
    def update_mode_indicator(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÇ‡∏´‡∏°‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        count = self.get_image_count()
        
        if count == 0:
            status = "‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö 1-4 ‡∏†‡∏≤‡∏û)"
        elif count == 1:
            status = f"üçå ‡πÇ‡∏´‡∏°‡∏î‡∏†‡∏≤‡∏û‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (1/4 ‡∏†‡∏≤‡∏û)"
        elif count == 2:
            status = f"üçå ‡πÇ‡∏´‡∏°‡∏î‡∏ú‡∏™‡∏°‡∏ú‡∏™‡∏≤‡∏ô (2/4 ‡∏†‡∏≤‡∏û)"
        elif count == 3:
            status = f"üçå ‡πÇ‡∏´‡∏°‡∏î‡∏°‡∏±‡∏•‡∏ï‡∏¥ (3/4 ‡∏†‡∏≤‡∏û)"
        elif count == 4:
            status = f"üçå ‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏° (4/4 ‡∏†‡∏≤‡∏û - ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î)"
        else:
            status = f"‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î ({count} ‡∏†‡∏≤‡∏û)"
            
        self.update_status(status)
    
    def prepare_session_contents(self, prompt_text):
        """üñºÔ∏è ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• contents ‡∏ï‡∏≤‡∏° slot-based management ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API"""
        # üéØ ‡∏™‡∏£‡πâ‡∏≤‡∏á prompt ‡∏ó‡∏µ‡πà‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
        active_image_paths = self.get_active_image_paths()
        image_count = len(active_image_paths)
        
        if image_count > 1:
            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏†‡∏≤‡∏û‡πÉ‡∏ô prompt
            image_refs = []
            for i, path in enumerate(active_image_paths):
                slot_num = self.image_paths.index(path) + 1  # 1-based slot number
                image_refs.append(f"Image {slot_num}")
            
            enhanced_prompt = f"{prompt_text}\n\n[Images: {', '.join(image_refs)} (Total: {image_count} images)]"
            contents = [enhanced_prompt]
        else:
            contents = [prompt_text]  # Single image, no need for references
        
        # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏†‡∏≤‡∏û‡∏ï‡∏≤‡∏° slot order (1-4) ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á
        for image_path in active_image_paths:
            try:
                with self._managed_image(image_path) as image:
                    if image.mode != 'RGB':
                        image = image.convert('RGB')
                        
                    # Resize ‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÉ‡∏ô BananaWorker)
                    max_size = 1024
                    if max(image.size) > max_size:
                        # Create a copy for resizing to avoid modifying the original
                        resized_image = image.copy()
                        resized_image.thumbnail((max_size, max_size), Image.Resampling.LANCZOS)
                        contents.append(resized_image)
                    else:
                        contents.append(image.copy())  # Use copy to avoid reference issues
            except Exception as e:
                print(f"[ERROR] Failed to load image {image_path}: {e}")
                continue
                
        return contents

    def start_session_generation(self, use_new_sdk: bool = True):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏ï‡∏≤‡∏° session ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        try:
            # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° contents ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API
            prompt_text = self.prompt_input.toPlainText().strip()
            
            # ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö multiple images ‡πÉ‡∏ä‡πâ ImageEditWorker ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö contents
            contents = self.prepare_session_contents(prompt_text)
            
            # ‡πÉ‡∏ä‡πâ ImageEditWorker ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö contents
            self.worker = ImageEditWorker(
                contents=contents,
                use_new_sdk=use_new_sdk
            )
            
            self.worker.finished.connect(self.on_generation_complete)
            self.worker.error.connect(self.on_generation_error)
            self.worker.status_update.connect(self.update_status)
            self.worker.start()
            
        except Exception as e:
            self.update_status(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: {str(e)}")
            # Re-enable buttons on error
            self.set_buttons_enabled(True)


# IPC functions removed for standalone version
# def send_image_to_existing_instance(image_path): ...
# def send_prompt_to_existing_instance(prompt_text): ...
# def is_banana_editor_running(): ...


class FloatingImageViewer(QWidget):
    """Floating image viewer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏ï‡πá‡∏° ‡∏û‡∏£‡πâ‡∏≠‡∏° scroll wheel zoom"""
    
    def __init__(self, image_path_or_paths, parent=None):
        super().__init__(parent)
        # Support both single path (str) and multiple paths (list)
        if isinstance(image_path_or_paths, str):
            self.image_paths = [image_path_or_paths]
        else:
            self.image_paths = list(image_path_or_paths)
        
        # Current image index
        self.current_index = 0
        self.image_path = self.image_paths[0]
        self.parent_widget = parent
        
        # Setup frameless window
        self.setWindowFlags(
            Qt.WindowType.FramelessWindowHint | 
            Qt.WindowType.WindowStaysOnTopHint |
            Qt.WindowType.Tool  # ‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô taskbar
        )
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        
        # Calculate appropriate target height based on screen size
        screen_geometry = QApplication.primaryScreen().geometry()
        screen_height = screen_geometry.height()
        screen_width = screen_geometry.width()
        
        # Use 80% of screen height as maximum, but not less than 400px
        max_height = int(screen_height * 0.8)
        self.target_height = min(960, max_height, screen_height - 100)  # Leave 100px for window decorations
        self.target_height = max(400, self.target_height)  # Minimum 400px
        
        # Store screen dimensions for width checking later
        self.max_width = int(screen_width * 0.9)  # Use 90% of screen width as maximum
        
        # Zoom properties
        self.zoom_factor = 1.0
        self.min_zoom = 0.10  # 10%
        self.max_zoom = 4.50  # 450%
        self.zoom_step = 0.1  # 10% increments
        self.original_pixmap = None
        
        self.image_widget = None
        self.overlay_widget = None
        
        # Navigation buttons
        self.prev_btn = None
        self.next_btn = None
        
        self.setup_ui()
        self.load_and_display_image()
        self.center_on_screen()
        
    def setup_ui(self):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö floating viewer"""
        # Set semi-transparent background
        self.setStyleSheet("""
            QWidget {
                background-color: rgba(31, 46, 31, 0.85);
            }
        """)
        
        # Create main layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(0)
        
        # Image label for displaying the image
        self.image_widget = QLabel(self)
        self.image_widget.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.image_widget.setScaledContents(False)
        self.image_widget.setStyleSheet("""
            QLabel {
                background-color: transparent;
                border: 1px solid #808080;
                border-radius: 4px;
                padding: 0px;
            }
        """)
        layout.addWidget(self.image_widget)
        
        # Navigation buttons (only show if multiple images)
        if len(self.image_paths) > 1:
            print(f"[FloatingViewer] Setting up navigation for {len(self.image_paths)} images")
            self.setup_navigation_buttons()
        else:
            print(f"[FloatingViewer] No navigation needed - single image")
            
    def setup_navigation_buttons(self):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏†‡∏≤‡∏û"""
        print("[FloatingViewer] Creating navigation buttons...")
        
        # Create navigation buttons directly on main widget (no container)
        button_style = """
            QPushButton {
                background-color: transparent;
                border: none;
                color: white;
                font-size: 16px;
                font-weight: bold;
                font-family: 'Arial Black', Arial, sans-serif;
                border-radius: 16px;
                padding: 6px;
                min-width: 20px;
                min-height: 20px;
                max-width: 20px;
                max-height: 20px;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.2);
                border-radius: 16px;
                padding: 6px;
                min-width: 32px;
                min-height: 32px;
                max-width: 32px;
                max-height: 32px;
            }
            QPushButton:pressed {
                background-color: rgba(255, 255, 255, 0.15);
                border-radius: 16px;
                padding: 6px;
                min-width: 32px;
                min-height: 32px;
                max-width: 32px;
                max-height: 32px;
            }
        """
        
        # Create buttons directly on the main widget
        self.prev_btn = QPushButton("‚Äπ", self)
        self.prev_btn.setStyleSheet(button_style)
        self.prev_btn.clicked.connect(self.prev_image)
        self.prev_btn.setToolTip("Previous image")
        self.prev_btn.setFixedSize(20, 20)
        print(f"[FloatingViewer] Prev button created: {self.prev_btn}")
        
        self.next_btn = QPushButton("‚Ä∫", self)
        self.next_btn.setStyleSheet(button_style)
        self.next_btn.clicked.connect(self.next_image)
        self.next_btn.setToolTip("Next image")
        self.next_btn.setFixedSize(20, 20)
        print(f"[FloatingViewer] Next button created: {self.next_btn}")
        
        # Position buttons immediately with manual coordinates
        self.position_nav_buttons_immediately()
        self.update_nav_button_states()
        
        # Bring to front and show
        self.prev_btn.raise_()
        self.next_btn.raise_()
        self.prev_btn.show()
        self.next_btn.show()
        
        print("[FloatingViewer] Navigation buttons setup completed")
        print(f"[FloatingViewer] Prev button visible: {self.prev_btn.isVisible()}")
        print(f"[FloatingViewer] Next button visible: {self.next_btn.isVisible()}")
        print(f"[FloatingViewer] Prev button size: {self.prev_btn.size()}")
        print(f"[FloatingViewer] Next button size: {self.next_btn.size()}")
        print(f"[FloatingViewer] FloatingViewer size: {self.size()}")
        
        print(f"[FloatingViewer] Navigation buttons created: prev at ({self.prev_btn.x()}, {self.prev_btn.y()}), next at ({self.next_btn.x()}, {self.next_btn.y()})")
        
    def position_nav_buttons_immediately(self):
        """‡∏à‡∏±‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ"""
        if not self.prev_btn or not self.next_btn:
            print("[FloatingViewer] Buttons not found for positioning")
            return
            
        # Position based on current widget size
        widget_width = self.width()
        widget_height = self.height()
        
        # Center buttons vertically (using actual button size 20px)
        button_y = (widget_height - 20) // 2  
        
        # Left and right positions with margins  
        prev_x = 15  # Small margin from left edge
        next_x = widget_width - 35  # 20px button width + 15px margin
        
        self.prev_btn.move(prev_x, button_y)  
        self.next_btn.move(next_x, button_y)
        
        print(f"[FloatingViewer] Widget size: {widget_width}x{widget_height}")
        print(f"[FloatingViewer] Button Y position: {button_y}")
        print(f"[FloatingViewer] Prev button at: ({prev_x}, {button_y})")
        print(f"[FloatingViewer] Next button at: ({next_x}, {button_y})")
        print(f"[FloatingViewer] Prev button geometry: {self.prev_btn.geometry()}")
        print(f"[FloatingViewer] Next button geometry: {self.next_btn.geometry()}")
        
    def load_and_display_image(self):
        """‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ï‡∏≤‡∏° aspect ratio ‡∏û‡∏£‡πâ‡∏≠‡∏° zoom functionality"""
        try:
            if not os.path.exists(self.image_path):
                self.show_error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏û")
                return
                
            # Load original pixmap and store it
            self.original_pixmap = QPixmap(self.image_path)
            if self.original_pixmap.isNull():
                self.show_error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ")
                return
                
            # Get original dimensions
            original_width = self.original_pixmap.width()
            original_height = self.original_pixmap.height()
                
            # Calculate display size with screen bounds checking
            aspect_ratio = original_width / original_height
            display_width = int(self.target_height * aspect_ratio)
            
            # Check if width exceeds screen bounds and adjust accordingly
            if display_width > self.max_width:
                display_width = self.max_width
                self.target_height = int(display_width / aspect_ratio)
                print(f"[FloatingViewer] Adjusted size to fit screen: {display_width}x{self.target_height}")
            
            # Store base dimensions (100% zoom level)
            self.base_width = display_width
            self.base_height = self.target_height
            
            # Apply zoom and display
            self.update_zoom_display()
            
        except Exception as e:
            print(f"[FloatingViewer] Error loading image: {e}")
            self.show_error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}")
    
            
    def show_error(self, message: str):
        """‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î"""
        self.image_widget.setText(f"‚ùå {message}")
        self.image_widget.setStyleSheet("""
            QLabel {
                color: #ff6b6b;
                background-color: rgba(0, 0, 0, 0.8);
                border: 1px solid #ff6b6b;
                border-radius: 4px;
                padding: 20px;
                font-size: 14px;
            }
        """)
        self.resize(400, 200)
        
    def center_on_screen(self):
        """‡∏à‡∏±‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏î‡πâ‡∏ß‡∏¢ smart positioning logic"""
        screen_geometry = QApplication.primaryScreen().geometry()
        screen_center_y = screen_geometry.height() // 2
        
        # ‡πÅ‡∏Å‡∏ô‡∏ï‡∏±‡πâ‡∏á (Y): ‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏™‡∏°‡∏≠
        window_y = screen_center_y - self.height() // 2
        
        # ‡πÅ‡∏Å‡∏ô‡∏ô‡∏≠‡∏ô (X): ‡∏¢‡∏∂‡∏î‡∏Å‡∏±‡∏ö‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á UI ‡∏´‡∏•‡∏±‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ parent
        if self.parent_widget:
            # ‡∏¢‡∏∂‡∏î‡∏Å‡∏±‡∏ö‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á UI ‡∏´‡∏•‡∏±‡∏Å (Banana Editor window)
            parent_geometry = self.parent_widget.geometry()
            parent_center_x = parent_geometry.x() + parent_geometry.width() // 2
            window_x = parent_center_x - self.width() // 2
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏•‡πâ‡∏ô‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Ç‡∏≠‡∏ö‡∏à‡∏≠
            screen_width = screen_geometry.width()
            if window_x < 0:
                window_x = 10  # padding ‡∏à‡∏≤‡∏Å‡∏Ç‡∏≠‡∏ö‡∏ã‡πâ‡∏≤‡∏¢
            elif window_x + self.width() > screen_width:
                window_x = screen_width - self.width() - 10  # padding ‡∏à‡∏≤‡∏Å‡∏Ç‡∏≠‡∏ö‡∏Ç‡∏ß‡∏≤
                
            # ‡∏¢‡πâ‡∏≤‡∏¢‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏î‡πâ
            self.move(window_x, window_y)
        else:
            # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ parent ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠
            screen_center_x = screen_geometry.width() // 2
            window_x = screen_center_x - self.width() // 2
            
            # ‡∏¢‡πâ‡∏≤‡∏¢‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÑ‡∏õ‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠
            self.move(window_x, window_y)
    
    def update_zoom_display(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ï‡∏≤‡∏° zoom level"""
        if not self.original_pixmap:
            return
            
        # Calculate current display size
        current_width = int(self.base_width * self.zoom_factor)
        current_height = int(self.base_height * self.zoom_factor)
        
        # Scale pixmap to current zoom level
        scaled_pixmap = self.original_pixmap.scaled(
            current_width,
            current_height,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation
        )
        
        # Set scaled image to label
        self.image_widget.setPixmap(scaled_pixmap)
        
        # Resize window to fit zoomed image + padding
        window_width = current_width + 40   # 20px padding on each side
        window_height = current_height + 40
        self.resize(window_width, window_height)
        
        # Center image in window
        self.image_widget.resize(current_width, current_height)
        self.image_widget.move(20, 20)  # 20px padding
        
        # Recenter window on screen after resize
        self.center_on_screen()
        
    def wheelEvent(self, event):
        """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ scroll wheel ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö zoom in/out"""
        # Get wheel delta (positive = zoom in, negative = zoom out)
        delta = event.angleDelta().y()
        
        if delta > 0:
            # Zoom in
            new_zoom = min(self.zoom_factor + self.zoom_step, self.max_zoom)
        else:
            # Zoom out
            new_zoom = max(self.zoom_factor - self.zoom_step, self.min_zoom)
        
        # Apply new zoom if changed
        if new_zoom != self.zoom_factor:
            self.zoom_factor = new_zoom
            self.update_zoom_display()
            
        # Accept event to prevent propagation
        event.accept()
        
    def reset_zoom(self):
        """‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï zoom ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ 100%"""
        self.zoom_factor = 1.0
        self.update_zoom_display()
        
    def mousePressEvent(self, event):
        """‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å (‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞ zoom ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà)"""
        # Close the viewer immediately regardless of zoom level
        self.close()
        super().mousePressEvent(event)
        
    def keyPressEvent(self, event):
        """Handle keyboard shortcuts:
        - ESC: ‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á
        - Left Arrow: Previous image
        - Right Arrow: Next image
        - Ctrl+V/Ctrl+P: Paste image from clipboard to 4-slot system 
        - Ctrl+Enter: Execute generation with New SDK
        """
        if event.key() == Qt.Key.Key_Escape:
            self.close()
        elif event.key() == Qt.Key.Key_Left:
            self.prev_image()
        elif event.key() == Qt.Key.Key_Right:
            self.next_image()
        else:
            super().keyPressEvent(event)
        
    def prev_image(self):
        """‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤"""
        if len(self.image_paths) <= 1:
            return
            
        self.current_index = (self.current_index - 1) % len(self.image_paths)
        self.image_path = self.image_paths[self.current_index]
        
        # Keep current zoom level and reload image
        current_zoom = self.zoom_factor  # ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤ zoom ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        self.load_and_display_image()
        self.zoom_factor = current_zoom  # ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ zoom
        self.update_zoom_display()  # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ï‡∏≤‡∏° zoom
        self.update_nav_button_states()
        
    def next_image(self):
        """‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏ñ‡∏±‡∏î‡πÑ‡∏õ"""
        if len(self.image_paths) <= 1:
            return
            
        self.current_index = (self.current_index + 1) % len(self.image_paths)
        self.image_path = self.image_paths[self.current_index]
        
        # Keep current zoom level and reload image
        current_zoom = self.zoom_factor  # ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤ zoom ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        self.load_and_display_image()
        self.zoom_factor = current_zoom  # ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ zoom
        self.update_zoom_display()  # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ï‡∏≤‡∏° zoom
        self.update_nav_button_states()
        
    def update_nav_button_positions(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏ô‡∏≥‡∏ó‡∏≤‡∏á"""
        if not self.prev_btn or not self.next_btn:
            return
        
        self.position_nav_buttons_immediately()
        
    def update_nav_button_states(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏°‡∏ô‡∏≥‡∏ó‡∏≤‡∏á"""
        if not self.prev_btn or not self.next_btn:
            return
            
        # Always enable if multiple images (circular navigation)
        self.prev_btn.setEnabled(len(self.image_paths) > 1)
        self.next_btn.setEnabled(len(self.image_paths) > 1)
        
        # Update tooltips with current position
        if len(self.image_paths) > 1:
            self.prev_btn.setToolTip(f"Previous image ({self.current_index + 1}/{len(self.image_paths)})")
            self.next_btn.setToolTip(f"Next image ({self.current_index + 1}/{len(self.image_paths)})")
    
    def showEvent(self, event):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏à‡∏±‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà"""
        super().showEvent(event)
        print("[FloatingViewer] showEvent triggered")
        if hasattr(self, 'prev_btn') and self.prev_btn:
            print("[FloatingViewer] Repositioning buttons in showEvent")
            # Use QTimer.singleShot to ensure widget is fully shown before positioning
            QTimer.singleShot(50, self.update_nav_button_positions)
    
    def resizeEvent(self, event):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠ resize"""
        super().resizeEvent(event)
        print(f"[FloatingViewer] resizeEvent: {event.size()}")
        if hasattr(self, 'prev_btn') and self.prev_btn:
            print("[FloatingViewer] Repositioning buttons in resizeEvent")
            self.update_nav_button_positions()
        
    def closeEvent(self, event):
        """Clean up ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á"""
        # Release image resources
        if self.image_widget and self.image_widget.pixmap():
            self.image_widget.clear()
        super().closeEvent(event)


def main():
    """Main function with command line argument support"""
    import argparse
    
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Banana Editor - Image-to-Image Editing Tool')
    parser.add_argument('--preload-image', type=str, help='Path to image file to preload')
    parser.add_argument('--image', type=str, help='Alias for --preload-image')
    args = parser.parse_args()
    
    # Get preload path (direct loading - no IPC)
    preload_path = args.preload_image or args.image
    app = QApplication(sys.argv)
    
    # Set application info
    app.setApplicationName("Banana Editor")
    app.setApplicationVersion("1.0.0")
    app.setOrganizationName("BananaEditor")
    
    # Enable high DPI support (PyQt6 handles this automatically)
    # app.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling)  # Not needed in PyQt6
    # app.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)     # Not needed in PyQt6
    
    # Create and show main window
    window = BananaEditor()
    
    # Preload image if specified
    if preload_path:
        print(f"[DEBUG] Preloading image: {preload_path}")
        window.preload_image(preload_path, clear_existing=True)  # Direct loading
    
    window.show()
    
    # Run application
    sys.exit(app.exec())


if __name__ == "__main__":
    main()